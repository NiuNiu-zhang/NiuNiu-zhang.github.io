{"meta":{"title":"NiuNiu","subtitle":"IT_小马哥","description":"NiuNiu的学习博客","author":"Zhang  Hao","url":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io","root":"/"},"pages":[],"posts":[{"title":"进程-linux","slug":"进程-linux","date":"2020-08-07T07:47:39.000Z","updated":"2020-08-07T07:47:39.779Z","comments":true,"path":"2020/08/07/进程-linux/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/07/%E8%BF%9B%E7%A8%8B-linux/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"网络编程传输协议详解","slug":"网络编程传输协议详解","date":"2020-08-07T07:46:19.000Z","updated":"2020-08-07T07:46:19.075Z","comments":true,"path":"2020/08/07/网络编程传输协议详解/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"诺瓦2020提前批笔试","slug":"诺瓦2020提前批笔试","date":"2020-08-07T02:21:03.000Z","updated":"2020-08-07T06:34:38.737Z","comments":true,"path":"2020/08/07/诺瓦2020提前批笔试/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/07/%E8%AF%BA%E7%93%A62020%E6%8F%90%E5%89%8D%E6%89%B9%E7%AC%94%E8%AF%95/","excerpt":"","text":"int main() &#123; int x = 0; return 0; &#125;","categories":[],"tags":[]},{"title":"线程-linux","slug":"线程-linux","date":"2020-08-05T07:47:14.000Z","updated":"2020-08-07T09:38:33.504Z","comments":true,"path":"2020/08/05/线程-linux/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/05/%E7%BA%BF%E7%A8%8B-linux/","excerpt":"","text":"线程–轻量级进程 // 内核调度的最小单元为了进一步减少处理器的空转时间，支持多处理器，减少上下文切换开销 上下文切换：指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换，上下文切换过程中的信息被保存在进程控制块（PCB-Process Control Block）中 过程： ` [1]先挂起一个进程，把这个进程在cpu中的状态（上下文信息）存储在内存的 PCB 中 [2]在PCB中检索下一个进程的上下文并将其在CPU的寄存器中恢复 [3]跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行）并恢复该进程` linux中的线程依赖于 pthread 线程库 1、创建线程： pthread_create( pthread_t * thread, pthread_attr_t *attr,void *( *start_routine)(void *), void * arg); thread: 线程标识符 attr: 线程属性设置， NULL 表示缺省属性 start_routine: 线程执行函数，参数和返回值都是 void * arg: 传递给 线程执行函数用的参数 return: success:0 error:错误码 2、退出线程: pthread_exit( void * retval ); retval: 线程结束时的返回值， 可以通过 pthread_join() 来接收//但是使用中不能用 exit 退出线程，因为一般一个进程中包含多个线程，exit的作用是使当前进程终止，进程中所以线程都会over—所以退出线程用 pthread_exit() 来替代 线程主动结束：可以调用 pthread_exit() 一个线程终止另外一个线程： 调用 pthread_cancel() 实现// 在被取消的线程内部要 先调用 pthread_setcancel() 和 pthread_setcanceltype() 设置相应的取消状态 3、pthread_join() 以阻塞的方式等待 thread 指定的线程结束，函数返回时，被等待线程的资源被回收，如果线程已经结束，该函数会立即返回 resutn: success:0 error:错误号 函数原型： pthread_ioin( pthread_t pthread, void ** thread_result ); thread:被等待线程的标识符 thread_result: 用户定义的指针，用来接收被等待线程结束时的返回值（如果返回不为NULL） **为什么是二级指针：**原因：一级指针只能用来改变指向内存的值，传递的就是指针p内存的地址,所以修改它就是修改了它自己的指向; 4、pthread_cancel( pthread_t thread ) thread: 要取消的线程的 标识符 return: success:0 error:错误码 线程函数使用 Demo // 编译的时候需要链接 pthread thread.h #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #define THREAD_NUM 3 // 线程数 #define REPEAT_TIMES 5 //每个线程中的循环次数限制 #define DELAY_TIME 6.0 //循环之间的最大时间间隔 线程处理函数 void * thread_function( void * arg){ int thread_num = (int )arg; //线程总数 int delay_time = 0; //延时 int count = 0; //计调用次数 printf(&quot;thread %d start!\\r\\n&quot;,thread_num); for (count=0;count&lt;REPEAT_TIMES; count++ ) &#123; delay_time = (int)( rand() * DELAY_TIME / (RAND_MAX) ) +1 ; sleep( delay_time ); //随机等待1--6 s, 模拟任务完成的时间随机 printf(&quot;Thread %d :job %d delay = %d\\r\\n&quot;, thread_num,count, delay_time); &#125; printf(&quot;Thread %d is finished\\r\\n&quot;, thread_num); pthread_exit(NULL); //任务完成自行结束 } main.c #include “thread.h” int main( void ){ pthread_t thread[THREAD_NUM]; //定义存放 thread 号的类型数组 int no = 0,res; void * thread_ret; srand( time( NULL )); //埋下时间种子 for( no=0; no&lt;THREAD_NUM; no++) &#123; res = pthread_create(&amp;thread[no], NULL, thread_function, (void*)no ); //创建的时候是 pthread_t * // no 标识是第几个线程 if ( res != 0 ) //create error &#123; printf(&quot;Create thread %d error\\r\\n&quot;, no); exit(res); // 结束进程， &lt;stdlib.h&gt; 参数不为0都异常 &#125; &#125; printf(&quot;Create threads success!\\r\\n&quot;); for( no=0;no&lt;THREAD_NUM;no++) &#123; // pthread_join: pthread_t thread res = pthread_join( thread[no], &amp;thread_ret); //阻塞式等待线程退出 //param_2 被等待线程结束的返回值, void ** thread_result if ( 0 == res ) //success:0 error:错误号 &#123; printf(&quot;Thread %d joined\\r\\n&quot;,no); &#125; else &#123; printf(&quot;Thread %d joined failed\\r\\n&quot;, no); &#125; &#125; return 0; } 运行情况：","categories":[{"name":"多进程/线程","slug":"多进程-线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"进制间转换","slug":"进制间转换","date":"2020-08-04T11:08:07.000Z","updated":"2020-08-04T16:58:12.302Z","comments":true,"path":"2020/08/04/进制间转换/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/04/%E8%BF%9B%E5%88%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"&lt;10进制—&gt;2进制&gt; ex: 19---> 19 / 2 = 9....1 9 / 2 = 4....1 4 / 2 = 2....0 2 / 2 = 1....0 1 / 2 = 0....1 反序取余数 10011 10进制中的 小数部分–&gt;2进制 ex: 0.75 小数不断×2取整，直到没有小数为止，注意:不是所有的小数都可以转为 2 进制 0.75 * 2 = 1.5 取整 1 0.5 * 2 = 1 顺序取数得: 0.11 &lt;16进制—-&gt; 10进制 &gt; 16进制 是 16 进 1 0 1 2 3 4 5 6 7 8 9 A(10) B C D E F(15) ex: 2AF5 = 5* 16^0 + F*16^1 + A*16^2 + 2*16^3 = 5 + 15*16 + 10*256 + 2*4096 = 5 + 240 + 2560 + 8192 = 10997 &lt;10进制 —-&gt; 16进制&gt; 余数定理分解 ex： 4877 4877 / 16 = 304....13 304 / 16 = 19....0 19 / 16 = 1.....3 1 / 16 = 0.....1 结果 = 130D (注意顺序)","categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"stm32-port1","slug":"stm32-port1","date":"2020-08-04T04:37:50.000Z","updated":"2020-08-04T04:37:50.998Z","comments":true,"path":"2020/08/04/stm32-port1/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/04/stm32-port1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-08-02T19:39:29.453Z","updated":"2020-08-07T06:54:22.548Z","comments":true,"path":"2020/08/03/hello-world/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/03/hello-world/","excerpt":"","text":"欢迎来到 NiuNiu 的技术经验分享博客网站但凡流行的工具、技术，都是入门易，精通难，想有所成就，都需要不懈的努力和漫长的积累，愿诸君与我共勉！回首向来萧瑟处，归去，也无风雨也无晴~","categories":[],"tags":[]},{"title":"单向不循环链表","slug":"单向不循环链表","date":"2020-08-01T16:48:16.000Z","updated":"2020-08-05T00:51:03.709Z","comments":true,"path":"2020/08/02/单向不循环链表/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/02/%E5%8D%95%E5%90%91%E4%B8%8D%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/","excerpt":"","text":"链表： 动态的数据结构，分为数据域和指针域， 动态进行存储分配，实现数据增删 优点： ​ 1、存储空间动态分配，可以根据实际需要使用 ​ 2、不需要地址连续的存储空间 ​ 3、插入/删除操作只需通过修改指针实现，不必移动数据元素， 操作时间效率高 ，插入删除事件复杂度 O(1) 缺点： ​ 1、每个链节点需要设置指针域（ 存储密度小 ） ​ 2、是一种非随机存储结构，查找/定位等操作都需要顺序扫描链表实现，时间效率低 O(n) [TOC] Demo/* 头节点:数据域为空 头节点:数据域为空 malloc 申请 &lt;malloc.h> memset 初始化 &lt;string.h> */ typedef int datatype; typedef struct link &amp;#123; datatype data; struct link * pNext; &amp;#125;Link; // 枚举 中间用, 未赋值默认第一个为0 enum opt &amp;#123; ERR=-1, OK, TAIL=-1, HEAD, &amp;#125;; // [1]创建链表---即生成头节点 Link * createLink(void); Link * createLink(void) &amp;#123; Link * pHead =NULL; pHead=(Link *)malloc(sizeof(Link)); if(NULL==pHead) &amp;#123; return NULL; &amp;#125; memset(pHead,'\\0',sizeof(Link)); return pHead; &amp;#125; // [2]插入节点---头插，尾插，中间插 //根据位置给链表添加节点 //参数：链表首地址，要添加的元素，和插入的位置 //HEAD=0 TAIL=-1 其他中间 //返回值 成功 OK 失败 ERR int InsertLink(Link * pHead, datatype item,int offset); int InsertLink(Link * pHead, datatype item,int offset) &amp;#123; if(NULL==pHead) &amp;#123; return ERR; &amp;#125; int k=0; Link * pNew=NULL; Link * pTmp=pHead; //如果写pHead->pNext要判断是否为空所以为了方便写pHead pNew=(Link *)malloc(sizeof(Link)); if(NULL==pNew) &amp;#123; return ERR; &amp;#125; pNew->data=item; pNew->pNext=NULL; switch(offset) &amp;#123; case HEAD: pNew->pNext=pHead->pNext; pHead->pNext=pNew; break; case TAIL: while(pTmp->pNext!=NULL) &amp;#123; pTmp=pTmp->pNext; &amp;#125; pTmp->pNext=pNew; break; default: while(k &lt; offset-1 &amp;&amp; pTmp != NULL) //pTmp!=NULL说明找到插入位置，如果pTmp==NULL,表示未找到要free(pNew)再返回报错 &amp;#123; k++; pTmp=pTmp->pNext; &amp;#125; if(pTmp==NULL) //先判断是否为空 &amp;#123; free(pNew); return ERR; &amp;#125; pNew->pNext=pTmp->pNext; pTmp->pNext=pNew; break; &amp;#125; &amp;#125; // [3]打印输出---遍历 int show(Link * pHead); int show(Link * pHead) &amp;#123; if(NULL==pHead) &amp;#123; return ERR; &amp;#125; Link * pTmp=pHead->pNext; while(pTmp!=NULL) &amp;#123; printf(\" %d \",pTmp->data); pTmp=pTmp->pNext; &amp;#125; printf(\"\\n\"); &amp;#125; // [4]删除节点----头删，尾删，中间删 int DeleteLink(Link * pHead,int offset,datatype * pData); int DeleteLink(Link * pHead,int offset,datatype * pData) &amp;#123; if(NULL==pHead||NULL==pData) &amp;#123; return ERR; &amp;#125; Link * pDel=NULL; Link * pPre=NULL; int k=0; switch(offset) &amp;#123; case HEAD: pDel=pHead->pNext; if(pDel==NULL) //一定要判断 &amp;#123; *pData=0; printf(\"链表为空！\\n\"); return ERR; &amp;#125; pHead->pNext=pDel->pNext; //先将删除的数保存 *pData=pDel->data; free(pDel); pDel=NULL; break; case TAIL: pPre=pHead; pDel=pHead->pNext; if(pDel==NULL) //说明没有什么删除的，空链表是pHead->pNext为空 &amp;#123; printf(\"链表为空!\\n\"); *pData=0; return ERR; while(pDel->pNext!=NULL) &amp;#123; pPre=pDel; pDel=pDel->pNext; &amp;#125; //保存删除的数据v *pData=pDel->data; free(pDel); pDel=NULL; //把pre变成尾节点 pPre->pNext=NULL; break; &amp;#125; default: pPre=pHead; pDel=pHead->pNext; k=0; while(k&lt;offset-1&amp;&amp;pDel!=NULL) &amp;#123; k++; pPre=pDel; //是pPre=pDel;; pDel=pDel->pNext; &amp;#125; if(pDel==NULL) &amp;#123; printf(\"链表为空!\\n\"); *pData=0; return ERR; &amp;#125; *pData=pDel->data; pPre->pNext=pDel->pNext; free(pDel); pDel=NULL; break; &amp;#125; &amp;#125; // [5]销毁链表 Link * Destroy(Link * pHead); Link * Destroy(Link * pHead) &amp;#123; if(NULL==pHead) &amp;#123; return NULL; &amp;#125; Link * pDel=NULL; //while(pDel!=NULL) //while(1)是死循环 永远成立； while(1) &amp;#123;//找到链表中的首节点 pDel=pHead->pNext; if(pDel==NULL) &amp;#123; break; &amp;#125; //保护好首节点后的所有节点 pHead->pNext=pDel->pNext; //释放首节点 free(pDel); pDel=NULL; &amp;#125; //最后再释放头节点 free(pHead); pHead=NULL; printf(\"链表已删除\\n\"); return pHead; //一定要返回 pHead 否则会错误 &amp;#125; // [6]链表逆序---拓展 int Negative(Link * pHead); //Negative sequence 逆序 int Negative(Link * pHead) //Negative sequence 逆序 &amp;#123; if(NULL==pHead) &amp;#123; return ERR; &amp;#125; Link * pA=NULL; Link * pB=NULL; pA=pHead->pNext; //保护好头节点后的所有节点 //原链表变为空链表 pHead->pNext=NULL; //保护好首节点后的所有节点 while(1) &amp;#123; pB=pA->pNext; //首节点插入到新链表 pA->pNext=pHead->pNext; pHead->pNext=pA; pA=pB; if(pA==NULL) &amp;#123; break; &amp;#125; &amp;#125; &amp;#125; testint main() &amp;#123; return 0; &amp;#125; int main()","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E9%93%BE%E8%A1%A8/"}]}],"categories":[{"name":"多进程/线程","slug":"多进程-线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"},{"name":"编程基础","slug":"编程基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"基础","slug":"基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"链表","slug":"链表","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E9%93%BE%E8%A1%A8/"}]}