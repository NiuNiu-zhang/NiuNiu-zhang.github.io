{"meta":{"title":"NiuNiu","subtitle":"IT_小马哥","description":"NiuNiu的学习博客","author":"Zhang  Hao","url":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io","root":"/"},"pages":[],"posts":[{"title":"进制间转换","slug":"进制间转换","date":"2020-08-04T11:08:07.000Z","updated":"2020-08-04T16:58:12.302Z","comments":true,"path":"2020/08/04/进制间转换/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/04/%E8%BF%9B%E5%88%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"&lt;10进制—&gt;2进制&gt; ex: 19---> 19 / 2 = 9....1 9 / 2 = 4....1 4 / 2 = 2....0 2 / 2 = 1....0 1 / 2 = 0....1 反序取余数 10011 10进制中的 小数部分–&gt;2进制 ex: 0.75 小数不断×2取整，直到没有小数为止，注意:不是所有的小数都可以转为 2 进制 0.75 * 2 = 1.5 取整 1 0.5 * 2 = 1 顺序取数得: 0.11 &lt;16进制—-&gt; 10进制 &gt; 16进制 是 16 进 1 0 1 2 3 4 5 6 7 8 9 A(10) B C D E F(15) ex: 2AF5 = 5* 16^0 + F*16^1 + A*16^2 + 2*16^3 = 5 + 15*16 + 10*256 + 2*4096 = 5 + 240 + 2560 + 8192 = 10997 &lt;10进制 —-&gt; 16进制&gt; 余数定理分解 ex： 4877 4877 / 16 = 304....13 304 / 16 = 19....0 19 / 16 = 1.....3 1 / 16 = 0.....1 结果 = 130D (注意顺序)","categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"stm32-port1","slug":"stm32-port1","date":"2020-08-04T04:37:50.000Z","updated":"2020-08-04T04:37:50.998Z","comments":true,"path":"2020/08/04/stm32-port1/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/04/stm32-port1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-08-02T19:39:29.453Z","updated":"2020-08-05T00:45:48.292Z","comments":true,"path":"2020/08/03/hello-world/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/03/hello-world/","excerpt":"","text":"{return 0;} &#123;return 0;&#125; int main(void) &amp;#123; printf(\" hello world \\r\\n\"); return 0; &amp;#125; Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"单向不循环链表","slug":"单向不循环链表","date":"2020-08-01T16:48:16.000Z","updated":"2020-08-05T00:51:03.709Z","comments":true,"path":"2020/08/02/单向不循环链表/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/02/%E5%8D%95%E5%90%91%E4%B8%8D%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/","excerpt":"","text":"链表： 动态的数据结构，分为数据域和指针域， 动态进行存储分配，实现数据增删 优点： ​ 1、存储空间动态分配，可以根据实际需要使用 ​ 2、不需要地址连续的存储空间 ​ 3、插入/删除操作只需通过修改指针实现，不必移动数据元素， 操作时间效率高 ，插入删除事件复杂度 O(1) 缺点： ​ 1、每个链节点需要设置指针域（ 存储密度小 ） ​ 2、是一种非随机存储结构，查找/定位等操作都需要顺序扫描链表实现，时间效率低 O(n) [TOC] Demo/* 头节点:数据域为空 头节点:数据域为空 malloc 申请 &lt;malloc.h> memset 初始化 &lt;string.h> */ typedef int datatype; typedef struct link &amp;#123; datatype data; struct link * pNext; &amp;#125;Link; // 枚举 中间用, 未赋值默认第一个为0 enum opt &amp;#123; ERR=-1, OK, TAIL=-1, HEAD, &amp;#125;; // [1]创建链表---即生成头节点 Link * createLink(void); Link * createLink(void) &amp;#123; Link * pHead =NULL; pHead=(Link *)malloc(sizeof(Link)); if(NULL==pHead) &amp;#123; return NULL; &amp;#125; memset(pHead,'\\0',sizeof(Link)); return pHead; &amp;#125; // [2]插入节点---头插，尾插，中间插 //根据位置给链表添加节点 //参数：链表首地址，要添加的元素，和插入的位置 //HEAD=0 TAIL=-1 其他中间 //返回值 成功 OK 失败 ERR int InsertLink(Link * pHead, datatype item,int offset); int InsertLink(Link * pHead, datatype item,int offset) &amp;#123; if(NULL==pHead) &amp;#123; return ERR; &amp;#125; int k=0; Link * pNew=NULL; Link * pTmp=pHead; //如果写pHead->pNext要判断是否为空所以为了方便写pHead pNew=(Link *)malloc(sizeof(Link)); if(NULL==pNew) &amp;#123; return ERR; &amp;#125; pNew->data=item; pNew->pNext=NULL; switch(offset) &amp;#123; case HEAD: pNew->pNext=pHead->pNext; pHead->pNext=pNew; break; case TAIL: while(pTmp->pNext!=NULL) &amp;#123; pTmp=pTmp->pNext; &amp;#125; pTmp->pNext=pNew; break; default: while(k &lt; offset-1 &amp;&amp; pTmp != NULL) //pTmp!=NULL说明找到插入位置，如果pTmp==NULL,表示未找到要free(pNew)再返回报错 &amp;#123; k++; pTmp=pTmp->pNext; &amp;#125; if(pTmp==NULL) //先判断是否为空 &amp;#123; free(pNew); return ERR; &amp;#125; pNew->pNext=pTmp->pNext; pTmp->pNext=pNew; break; &amp;#125; &amp;#125; // [3]打印输出---遍历 int show(Link * pHead); int show(Link * pHead) &amp;#123; if(NULL==pHead) &amp;#123; return ERR; &amp;#125; Link * pTmp=pHead->pNext; while(pTmp!=NULL) &amp;#123; printf(\" %d \",pTmp->data); pTmp=pTmp->pNext; &amp;#125; printf(\"\\n\"); &amp;#125; // [4]删除节点----头删，尾删，中间删 int DeleteLink(Link * pHead,int offset,datatype * pData); int DeleteLink(Link * pHead,int offset,datatype * pData) &amp;#123; if(NULL==pHead||NULL==pData) &amp;#123; return ERR; &amp;#125; Link * pDel=NULL; Link * pPre=NULL; int k=0; switch(offset) &amp;#123; case HEAD: pDel=pHead->pNext; if(pDel==NULL) //一定要判断 &amp;#123; *pData=0; printf(\"链表为空！\\n\"); return ERR; &amp;#125; pHead->pNext=pDel->pNext; //先将删除的数保存 *pData=pDel->data; free(pDel); pDel=NULL; break; case TAIL: pPre=pHead; pDel=pHead->pNext; if(pDel==NULL) //说明没有什么删除的，空链表是pHead->pNext为空 &amp;#123; printf(\"链表为空!\\n\"); *pData=0; return ERR; while(pDel->pNext!=NULL) &amp;#123; pPre=pDel; pDel=pDel->pNext; &amp;#125; //保存删除的数据v *pData=pDel->data; free(pDel); pDel=NULL; //把pre变成尾节点 pPre->pNext=NULL; break; &amp;#125; default: pPre=pHead; pDel=pHead->pNext; k=0; while(k&lt;offset-1&amp;&amp;pDel!=NULL) &amp;#123; k++; pPre=pDel; //是pPre=pDel;; pDel=pDel->pNext; &amp;#125; if(pDel==NULL) &amp;#123; printf(\"链表为空!\\n\"); *pData=0; return ERR; &amp;#125; *pData=pDel->data; pPre->pNext=pDel->pNext; free(pDel); pDel=NULL; break; &amp;#125; &amp;#125; // [5]销毁链表 Link * Destroy(Link * pHead); Link * Destroy(Link * pHead) &amp;#123; if(NULL==pHead) &amp;#123; return NULL; &amp;#125; Link * pDel=NULL; //while(pDel!=NULL) //while(1)是死循环 永远成立； while(1) &amp;#123;//找到链表中的首节点 pDel=pHead->pNext; if(pDel==NULL) &amp;#123; break; &amp;#125; //保护好首节点后的所有节点 pHead->pNext=pDel->pNext; //释放首节点 free(pDel); pDel=NULL; &amp;#125; //最后再释放头节点 free(pHead); pHead=NULL; printf(\"链表已删除\\n\"); return pHead; //一定要返回 pHead 否则会错误 &amp;#125; // [6]链表逆序---拓展 int Negative(Link * pHead); //Negative sequence 逆序 int Negative(Link * pHead) //Negative sequence 逆序 &amp;#123; if(NULL==pHead) &amp;#123; return ERR; &amp;#125; Link * pA=NULL; Link * pB=NULL; pA=pHead->pNext; //保护好头节点后的所有节点 //原链表变为空链表 pHead->pNext=NULL; //保护好首节点后的所有节点 while(1) &amp;#123; pB=pA->pNext; //首节点插入到新链表 pA->pNext=pHead->pNext; pHead->pNext=pA; pA=pB; if(pA==NULL) &amp;#123; break; &amp;#125; &amp;#125; &amp;#125; testint main() &amp;#123; return 0; &amp;#125; int main()","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E9%93%BE%E8%A1%A8/"}]}],"categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"链表","slug":"链表","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E9%93%BE%E8%A1%A8/"}]}