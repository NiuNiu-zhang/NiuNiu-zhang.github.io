{"meta":{"title":"NiuNiu","subtitle":"IT_小马哥","description":"NiuNiu的学习博客","author":"Zhang  Hao","url":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io","root":"/"},"pages":[],"posts":[{"title":"进程间通信-管道","slug":"管道","date":"2020-08-10T08:10:45.000Z","updated":"2020-08-10T11:23:11.526Z","comments":true,"path":"2020/08/10/管道/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/10/%E7%AE%A1%E9%81%93/","excerpt":"","text":"Linux 进程间通讯 ：1、无名管道2、有名管道3、信号4、消息队列5、共享内存6、信号量7、套接字 管道操作：一个进程往管道中写入数据，另一个进程从管道中读出数据 包括[1]有名管道——————FIFO–先进先出&ensp; &ensp; &ensp; 又称为 FIFO 文件，有名管道一旦创建完成后，linux会创建一个文件，对文件进行读写，就实现进程间的 数据通信 了。注意：FIFO 文件只能以 RDONLY 的方式读取打开 或者 WRONLY 的方式写打开FIFO 中的内容被读取后，就消失了，但是普通文件内容读取后不会消失对有名管道的操作可以用常规的 文件 IO 操作：1—-&gt; 创建有名管道 123456789101112131415161718192021222324#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt; int mkfifo(const char *pathname, mode_t mode) //mknod //pathname:要创建的FIFO文件名(带路径) //mode :创建的文件的权限 0777 可读可写可执行 0666 读写 //EEXIST 代表文件已经存在的错误码 demo if ( ( mkfifo( MYFIFO, O_CREAT | O_EXCL) &lt; 0 ) &amp;&amp; ( errno != EEXIST )/* or mknod*/ ) &#123; printf(&quot;create fifo error!\\r\\n&quot;); return errno; //返回错误码 EAGAIN 宏从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。demo if ( -1 == (real_read = read(fd, read_buffer, UNIT_SIZE ))) &#123; if (errno == EAGAIN ) &#123; printf(&quot;No data yet\\r\\n&quot;); &#125; &#125; &#125; return: success: FIFO的文件描述符 error: -12—-&gt; 删除有名管道 123#include &lt;unistd.h&gt; int unlink(const char *pathname) return: success:0 error: -1 3—-&gt; 示例使用一个存在的有名管道之前，需要用open（）将其打开。因为有名管道是一个存在于硬盘上的文件，而管道是存在于内存中的特殊文件。以下程序演示有名管道在无亲缘关系的进程之间如何通信。 12345678910void main()&#123; int fd; char * p =&quot;weiqi7777 world\\r\\n&quot;; mkfifo(&quot;fifo.txt&quot;, 0777); fd = open(&quot;fifo.txt&quot;, O_WRONLY); //写 write(fd,p, strlen(p)+1); //strlen的话不计算 \\n， sizeof计算 close(fd);&#125; 注意：有名管道必须用于两进程，一写一读，只写不读会卡在那里，阻塞demo：write.c 123456789101112131415161718192021222324252627282930313233343536//有名管道 fifo 的写端代码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#define FIFO_NAME &quot;myfifo&quot;#define BUF_SIZE 1024int main( void )&#123; int fd; char buf[BUF_SIZE] = &quot;Hello procwrite, I come from process named procread!&quot;; // 因为不知道 谁会操作，修改权限掩码 umask( 0 ); //指明创建一个有名管道且存取权限为0666，即创建者、与创建者同组的用户、其他用户对该有名管道的访问权限都是可读可写 if ( mkfifo( FIFO_NAME, 0666) == -1 ) //mknod &#123; perror(&quot;mkfifo error\\r\\n&quot;); exit(1); // 0是正常，其他异常退出 &#125; if ( -1 == ( fd = open(FIFO_NAME, O_WRONLY ) )) //以写方式打开管道 &#123; perror(&quot;fopen error!\\r\\n&quot;); exit(1); &#125; write( fd, buf, strlen(buf) + 1 ); //向 fifo 写数据 close(fd); exit(0);&#125; read.c 123456789101112131415161718192021222324252627282930// 有名管道的 读端 代码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#define FIFO_NAME &quot;myfifo&quot;#define BUF_SIZE 1024int main( void )&#123; int fd; char buf[BUF_SIZE]; umask(0); fd = open( FIFO_NAME, O_RDONLY); int ret = read(fd, buf, BUF_SIZE ); if ( -1 == ret ) &#123; perror(&quot;read error!\\r\\n&quot;); exit(ret); &#125; printf(&quot;read %s from %s&quot;,buf,FIFO_NAME ); close(fd); exit(0);&#125; 运行效果： [2]无名管道c","categories":[],"tags":[{"name":"有名管道","slug":"有名管道","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93/"}]},{"title":"生产者消费者demo-有名管道+信号量","slug":"生产者消费者demo-有名管道-信号量","date":"2020-08-10T00:57:06.000Z","updated":"2020-08-10T11:23:10.198Z","comments":true,"path":"2020/08/10/生产者消费者demo-有名管道-信号量/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/10/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85demo-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93-%E4%BF%A1%E5%8F%B7%E9%87%8F/","excerpt":"","text":"生产者-消费者 Demo相关描述：有一个有限缓冲区，（用有名管道实现 FIFO 式缓冲区）有两个线程，生产者和消费者，它们分别不停的把产品放入缓冲区 和 从缓冲区中拿走产品一个生产者在 缓冲区 满的时候必须等待消费者缓冲区 空的时候也必须等待因为缓冲区时是 临界资源， 所以生产者消费者必须互斥执行临界资源： // 一次仅允许一个进程使用的 共享资源&ensp; &ensp;&ensp;//各进程采取互斥的方式，实现共享的资源称作 临界资源&ensp; &ensp;&ensp;//消息队列、变量、数组、缓冲区—– 生产者—&gt; | 缓冲区资源 | –&gt; 消费者用有名管道来模拟 有限缓冲区有名管道：有名管道是一个能在互不相关进程之间传送数据的特殊文件，一个或多个进程向内写入数据，在另一端由一个进程负责读出，有名管道在文件系统中可见， ls， 又称为 FIFO ，先入先出–&amp;&amp;&amp;wht？ 如何建立有名管道？shell 交互创建有名管道 mknod // mkfifo 命令在有些系统中， mkond 产生的文件可能在 /etc 目录下程序中建立有名管道： 123456umask(0); //明确设置 umask，因为不知道谁会读写管道if ( mknod /*mkfifo*/ (&quot;test_fifo&quot;, S_IRUSR | S_IWUSR | S_IRUSR | S_IWGRP))&#123; perror(&quot;mkfifo&quot;); exit(0);&#125; 有名管道使用：用 read() 和 write() 进行操作如果用 读写方式 O_RDWR 方式打开， 则不会引起阻塞 使用 3 个信号量– 其中 avail 和 full 分别用来解决生产者和消费者线程间的同步问题avail 标识缓冲区中的空单元数， 初始值是 Nfull 标识缓冲区中的非空单元数，初始值是 0mutex 是互斥信号量， 初始值是 1—也可以用互斥锁实现 流程： 开始–&gt;建立有名管道–&gt;打开有名管道–&gt;初始化 3 个信号量–&gt;创建生产者、消费者线程 [1]生产者线程：p操作 avail(白嫖操作)—-&gt;p操作 mutex—–&gt;读管道—-&gt;V操作 full—-&gt;V操作 mutex—&gt;结束 [2]消费者线程：p操作 full –&gt; p操作 mutex–&gt; 写管道—&gt; V操作 avail—-&gt;v—mutex—&gt;结束 缓冲区3个单元，每个单元10字节，生成和消费过程随机(0-5s的随机时间间隔，而且生产者的速度差不多是消费者的 2 倍，) src： producer_customer.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;pthread.h&gt;// 相关头文件包含#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt; //#include &lt;semaphore.h&gt; //#include &lt;sys/ipc.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;// 警告不兼容 memset， 要包含头文件 string.h#include &lt;string.h&gt;#define MYFIFO &quot;myfifo&quot; //缓冲区有名管道的名字#define BUFFER_SIZE 3 //缓冲区的单元数#define UNIT_SIZE 10 //每个单元的大小#define RUN_TIME 30 //运行时间#define DELAY_TIME 5.0 //周期的最大值int fd; //全局定义文件描述符//pthread_mutex_t mutex;sem_t sem_mutex; //这里不是互斥锁，而是 信号量 sem_tsem_t avail, full;time_t end_time; //结束时间// 生产者线程处理函数void * producer( void * arg)&#123; int real_write; int delay_time = 0; // time_t time = time( NULL ); 获取系统时间，单位为s while( time(NULL) &lt; end_time ) //当前系统时间小于预定的结束时间 &#123; // 给延时时间赋随机值 // rand() 产生一个 0--0x7fff 即 0--32767 之间的随机数 // stdlib.h 中有 #define RAND_MAX 0X7fff // rand() / (RAND_MAX + 1.0 ) 就等于一个 0-1 之间的小数 // 分析： rand()最大 32767 最小 0 除以32767 就是 0-1 之间小数 // 不能等于1 再乘以 10就是 0-10 不等于 10，最后在加1 就是 // 0-10可以取到10了 // 另外一种方法生成 一定范围内的随机数 // int a = rand() % 10; 0-9 10会被整除，取不到 // 规定上下限 int a = rand() % 51 + 13; 13-63 // 因为 %51 最大取50 + 13 保证最大 63 delay_time = (int)( rand() * DELAY_TIME / ( RAND_MAX) /2.0 ) +1; sleep( delay_time ); printf(&quot;Producer:delay=%d\\r\\n&quot;,delay_time); // p 操作，白嫖先用， 信号量-1 sem_wait sem_wait( &amp;avail ); // avail 缓冲区的空单元 初始N 初始5, -1=4 sem_wait( &amp;sem_mutex ); //int * semvalue = NULL; int numsem; sem_getvalue( &amp;avail, &amp;numsem); printf(&quot;avail=%d\\r\\n&quot;, numsem ); // 把 sem 指向的信号量 当前值 放置在 semvalue 指向的整数上 成功返回 0, // error: -1 //sem_getvalue( &amp;avail, semvalue ); //printf(&quot;avail=%d\\r\\n&quot;, *semvalue ); //得到sem 的值要用 sem_getvalue /*生产者写入数据 */ if ( -1 == ( real_write = write(fd,&quot;hello you&quot;, UNIT_SIZE ) ) ) &#123; if ( errno == EAGAIN ) &#123; printf(&quot;The fifo has not been read yet,please try later\\r\\n&quot;); &#125; &#125; else //写入成功 &#123; printf(&quot;write %d to the fifo\\r\\n&quot;,real_write ); &#125; // V 操作释放 mutex-操作权 和 // full----full是fifo缓冲区的非空单元数，初始为 0，V操作 +1 // 当 full == size 的时候 就没有非空了 ，无法写 sem_post sem_post( &amp;full ); //full+1------- 0 +1 =1 sem_post( &amp;sem_mutex ); //sem_mutex 初始值1， 0 + 1 =1 &#125; pthread_exit( NULL );&#125;void * customer( void * arg)&#123; // 定义 buff 用于保存读出的数据 unsigned char read_buffer[ UNIT_SIZE ]; int real_read; //实际读出的字节数 int delay_time; while ( time(NULL ) &lt; end_time ) &#123; delay_time = (int)( rand() * DELAY_TIME / ( ( RAND_MAX)) / 2.0) + 1 ; sleep( delay_time ); int numsem; sem_getvalue(&amp;sem_mutex, &amp;numsem ); printf(&quot;Custom:sem_mutex=%d\\r\\n&quot;,numsem ); // p 操作 full 和 mutex 信号量 sem_wait( &amp;full ); //将 代表 非空单元数， -1, 没有可读的就阻塞，用于保证生产者先生产 sem_wait( &amp;sem_mutex ); // sem_mutex -1 = 0 //sem_getvalue(&amp;sem_mutex, &amp;numsem ); //printf(&quot;Custom:sem_mutex=%d\\r\\n&quot;,numsem ); // memset memset( read_buffer, &#x27;0&#x27;,UNIT_SIZE ); printf(&quot;Customer:delay=%d\\r\\n&quot;,delay_time); if ( -1 == (real_read = read(fd, read_buffer, UNIT_SIZE ))) &#123; if (errno == EAGAIN ) &#123; printf(&quot;No data yet\\r\\n&quot;); &#125; &#125; printf(&quot;read %s from fifo\\r\\n&quot;,read_buffer); // V 操作信号量，释放资源 mutex avail sem_post( &amp;avail ); //读取完让 avail + 1，可写的多一个 sem_post( &amp;sem_mutex ); &#125; pthread_exit(NULL); &#125; main.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;producer_customer.h&quot;int main()&#123; // 定义生产者和消费者的线程描述符 pthread_t producer_id, customer_id; int ret; // 先埋下种子 srand(time(NULL) ); end_time = time( NULL ) + RUN_TIME ; //定义结束时间 // 创建有名管道 fifo if ( ( mkfifo( MYFIFO, O_CREAT | O_EXCL) &lt; 0 ) &amp;&amp; ( errno != EEXIST )/* or mknod*/ ) &#123; printf(&quot;create fifo error!\\r\\n&quot;); return errno; //返回错误码 &#125; // open fifo fd = open( MYFIFO, O_RDWR); //可读可写 O_RDWR if ( -1 == fd ) &#123; perror(&quot;open fifo error\\r\\n&quot;); return fd; &#125; // 初始化 init 信号量为 1 ret = sem_init(&amp;sem_mutex, 0, 1); //0代表只用于线程间， 1是mutex的初始化值 // 初始化 avail 的信号量为 N 成功 0 失败 -1 ret += sem_init( &amp;avail, 0, BUFFER_SIZE ); // 初始化 full 信号量 为 0 ret += sem_init( &amp;full, 0, 0); if ( 0 != ret) &#123; perror(&quot;some sem init error!\\r\\n&quot;); return ret; &#125; // 创建两个线程 ret = pthread_create( &amp;producer_id, NULL , producer, NULL); //有参的话传入 void * if ( 0 != ret ) &#123; perror(&quot;create pthread_producer error!\\r\\n&quot;); return ret; &#125; ret = pthread_create( &amp;customer_id, NULL, customer, NULL); if ( 0 != ret ) &#123; perror(&quot;create pthread_customer error!\\r\\n&quot;); return ret; &#125; // 阻塞等待线程结束 pthread_join pthread_join( producer_id, NULL ); //void ** result pthread_join( customer_id, NULL ); close(fd ); //关闭打开的文件描述符 unlink( MYFIFO ); //关闭管道连接 return 0;&#125; 运行结果:","categories":[{"name":"生产者消费者demo","slug":"生产者消费者demo","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85demo/"}],"tags":[{"name":"有名管道，信号量","slug":"有名管道，信号量","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%87%8F/"}]},{"title":"线程-demo问题","slug":"线程-demo问题","date":"2020-08-09T09:29:28.000Z","updated":"2020-08-10T11:23:08.790Z","comments":true,"path":"2020/08/09/线程-demo问题/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/09/%E7%BA%BF%E7%A8%8B-demo%E9%97%AE%E9%A2%98/","excerpt":"","text":"src：thread.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#define PTHREAD_NUM 2#define NUM 0#define PARAM 0pthread_mutex_t mutex;void * pthread_func_1( void * arg);void * pthread_func_1( void * arg)&#123; //int count = *((int *)arg); int count = (int )arg; printf(&quot;count=%d\\r\\n&quot;,count); int param = PARAM; int res = 0; // arg 用来标识是哪个线程 if( 0 == count ) &#123; while(1) &#123; // lock if ( 0 != (res = pthread_mutex_lock(&amp;mutex) ) ) &#123; perror(&quot;lock error!\\r\\n&quot;); pthread_exit(NULL); &#125; printf(&quot;thread %d lock\\r\\n&quot;,count ); // 线程 1 param = 0; printf(&quot;thread 1: param=%d\\r\\n&quot;,param); //unlock if ( 0 != ( res = pthread_mutex_unlock(&amp;mutex) )) &#123; perror(&quot;unlock error!\\r\\n&quot;); pthread_exit(NULL); &#125; printf(&quot;thread %d unlock\\r\\n&quot;,count); sleep(2); &#125; &#125; else if( 1 == count ) &#123; while(1) &#123; // lock if ( 0 != (res = pthread_mutex_lock(&amp;mutex) ) ) &#123; perror(&quot;lock error!\\r\\n&quot;); pthread_exit(NULL); &#125; printf(&quot;thread %d lock\\r\\n&quot;,count ); // 线程 1 param = 1; printf(&quot;thread 1: param=%d\\r\\n&quot;,param); //unlock if ( 0 != ( res = pthread_mutex_unlock(&amp;mutex) )) &#123; perror(&quot;unlock error!\\r\\n&quot;); pthread_exit(NULL); &#125; printf(&quot;thread %d unlock\\r\\n&quot;,count); sleep(2); &#125; &#125; return (void *)0;&#125; main.c 123456789101112131415161718192021222324252627282930#include &quot;thread.h&quot;int main( void )&#123; // 初始化 锁 pthread_mutex_init(&amp;mutex, NULL); pthread_t thread[PTHREAD_NUM]; // pthread_t 数组 保存生成的 pthread_t 线程描述符 // create thread int num=0,res=0; for (num=0;num&lt;PTHREAD_NUM;num++) &#123; res=pthread_create( &amp;thread[num],NULL,pthread_func_1,(void *)num ); if ( 0 != res ) &#123; perror(&quot;create pthread error\\r\\n&quot;); exit(res); &#125; printf(&quot;thread %d create success!\\r\\n&quot;,num); &#125; printf(&quot;pthread create success,wait for:\\r\\n&quot;); // destroy sleep(10); pthread_mutex_destroy(&amp;mutex); return 0;&#125; 运行效果：","categories":[{"name":"进程线程","slug":"进程线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"线程bug","slug":"线程bug","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8Bbug/"}]},{"title":"线程-信号量","slug":"线程-信号量","date":"2020-08-08T16:34:24.000Z","updated":"2020-08-10T11:23:07.056Z","comments":true,"path":"2020/08/09/线程-信号量/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/09/%E7%BA%BF%E7%A8%8B-%E4%BF%A1%E5%8F%B7%E9%87%8F/","excerpt":"","text":"信号量就是： （主要用于共享数据的同步访问）操作系统中用到的 PV 原子操作，广泛应用于进程和线程间的同步和互斥本质：是一个 非负 的整数计数器，被用来控制对公共资源的访问PV 操作主要用于 同步 和 互斥 两种应用场景 linux 实现 POSIX 的无名信号量用于线程间的同步互斥 sem接口函数操作的参数都是信号量指针 sem_t *[1]初始化信号量#include &lt;semaphore.h&gt; 12345int sem_init( sem_t * sem, int pshared, unsigned int value);sem:信号量对象 pshared：决定信号量是否在线程间共享，目前未实现，默认0，标识只能进程内的线程间 共享value：信号量初始化值return: success:0 error:-1 [2]sem_wait() 和 sem_trywait() 相当于 p 操作———-P 代表白嫖p， 用内容在信号量 &gt; 0 时能将信号量值 -1，区别：信号量为 0 时， sem_wait 会阻塞， sem_trywait 立即返回 1int sem_wait( sem_t * sem ); //获取信号量，不成功则----阻塞 [3]sem_post() 相当于 V 操作——-V 释放 将信号量的值 +1， 同时唤醒等待的线程 1int sem_post( sem_t * sem ); //释放信号量 [4]sem_getvalue() 获得信号量的值 [5]sem_destroy() 删除信号量 1、 互斥几个进程（或线程）往往只设置一个信号量 sem。 2、同步信号量用于同步操作时， 往往会设置多个信号量，并安排不同的初始值来实现 它们 之间的顺序执行","categories":[{"name":"进程线程","slug":"进程线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"信号量","slug":"信号量","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"}]},{"title":"线程-互斥锁","slug":"线程间同步互斥","date":"2020-08-08T02:38:51.000Z","updated":"2020-08-10T11:22:22.432Z","comments":true,"path":"2020/08/08/线程间同步互斥/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/08/%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/","excerpt":"","text":"由于线程共享进程的资源和地址空间，因此在对资源操作时，必须考虑到线程间资源的访问和互斥问题 1、互斥锁线程控制&ensp; &ensp;&ensp;&ensp;&ensp;互斥锁通过简单的方式保证对共享资源的原子操作&ensp; &ensp;&ensp;&ensp;&ensp;原子操作是不可分割的，在执行完毕之前不会被任何其它任务或事件中断 互斥锁操作： 上锁 和 解锁同一时刻只能有一个线程持有某个互斥锁，拥有互斥锁的线程能够对共享资源进行操作，若线程对一个已经被上锁的互斥锁加锁，该线程就会睡眠，直到其他线程释放掉互斥锁为止。互斥锁机制实现函数：#include &lt;pthread.h&gt;[1]互斥锁初始化： 123pthread_mutex_init( pthread_mutex_t * mutex, const pthread_mutexattr_t * mutexattr);mutex；互斥锁 mutexattr:互斥锁属性， NULL 标识缺省参数return: success:0 error:错误码 [2]互斥锁上锁： 1pthread_mutex_lock( pthread_mutex_t * mutex ); //加锁，不成功则阻塞自己 [3]互斥锁判断上锁 1pthread_mutex_trylock( pthread_mutex_t * mutex); //加锁，若不成功则返回，立即返回！！ [4]互斥锁解锁 1pthread_mutex_unlock( pthread_mutex_t * mutex ); [5]消除/摧毁 互斥锁 1pthread_mutex_destroy( pthread_mutex_t * mutex ); 线程间互斥锁Demo：pthread_mutex.h 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define THREAD_NUM 3 //定义线程数#define REPEAT_TIMES 3 //定义线程的循环次数#define DELAY_TIME 6.0 //定义循环之间的最大时间间隔pthread_mutex_t mutex; //定义全局的线程互斥锁// 线程的功能函数void * thread_function( void * arg )&#123; int thread_num = (int)arg; //标识是哪一个线程 int delay_time = 0,count=0; //count计数 int res; // lock res = pthread_mutex_lock( &amp;mutex ); if( 0 != res ) //or ( res ) &#123; printf(&quot;Thread %d lock failed\\r\\n&quot;, thread_num); pthread_exit( NULL ); &#125; printf(&quot;Thread %d is start\\r\\n&quot;, thread_num); for(count=0;count&lt;REPEAT_TIMES; count++ ) &#123; delay_time = (int)( rand()*DELAY_TIME/(RAND_MAX)) +1; sleep( delay_time ); printf(&quot;Thread %d :job:%d,delay:%d&quot;,thread_num,count,delay_time); &#125; printf(&quot;Thread %d finish\\r\\n&quot;,thread_num); // unlock pthread_mutex_unlock( &amp;mutex); pthread_exit(NULL);&#125; main.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &quot;pthread_mutex.h&quot;int main(void )&#123; pthread_t thread[THREAD_NUM ]; //创建pthread_t 类型的数组标识线程 标识符 //解析：之所以用数组没有初始化直接传参是create函数会返回phread_t 类型，指针用于返回值 int no = 0,res; void * thread_res; srand(time(NULL)); // mutex_init pthread_mutex_init( &amp;mutex, NULL ); for ( no=0;no&lt;THREAD_NUM;no++) &#123; // create pthread res = pthread_create(&amp; thread[no], NULL, thread_function, (void *)no ); //最后是线程功能函数需要的参数 if ( 0 != res ) &#123; printf(&quot;Create thread %d failed\\r\\n&quot;,no ); exit(res); &#125; &#125; printf(&quot;Create all success,wait for finish\\r\\n&quot;); //阻塞式等待结束 for(no=0;no&lt;THREAD_NUM;no++) &#123; res = pthread_join( thread[no], &amp;thread_res ); //param2：接收被等候待线程结束返回值 是 void ** if ( 0 == res ) //or (!res) &#123; printf(&quot;Thread %d joined&quot;, no); &#125; else &#123; printf(&quot;Thread %d joined failed\\r\\n&quot;,no); &#125; &#125; pthread_mutex_destroy( &amp;mutex); return 0;&#125; 执行结果","categories":[{"name":"进程线程","slug":"进程线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"线程通信","slug":"线程通信","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"}]},{"title":"进程-linux","slug":"进程-linux","date":"2020-08-07T07:47:39.000Z","updated":"2020-08-07T07:47:39.779Z","comments":true,"path":"2020/08/07/进程-linux/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/07/%E8%BF%9B%E7%A8%8B-linux/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"网络编程传输协议详解","slug":"网络编程传输协议详解","date":"2020-08-07T07:46:19.000Z","updated":"2020-08-07T07:46:19.075Z","comments":true,"path":"2020/08/07/网络编程传输协议详解/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"诺瓦2020提前批笔试","slug":"诺瓦2020提前批笔试","date":"2020-08-07T02:21:03.000Z","updated":"2020-08-09T09:47:13.111Z","comments":true,"path":"2020/08/07/诺瓦2020提前批笔试/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/07/%E8%AF%BA%E7%93%A62020%E6%8F%90%E5%89%8D%E6%89%B9%E7%AC%94%E8%AF%95/","excerpt":"","text":"flight.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#ifndef HEAD_H#define HEAD_H/* * description: * 航班和乘客，乘客中用 GREEN、YELLOW、RED 标识身体情况， 规则: * 一列航班中 RED==0 没有问题 * RED &gt; 10% 紧急停机检查 * 0 &lt; RED &lt; 10% * 有风险，抵达目的地后进行检查 * 代码实现 **/// &lt;封装 乘客struct&gt; select 链表typedef struct passenger&#123; char * name; char * id_card; struct passenger * pNext; int flight_id; int healthcode; // 乘客的健康等级&#125;passenger_t;// &lt;封装 flight struct&gt;typedef struct flight&#123; const char * orig_city;//初始地 const char * dest_city; int flight_id; struct flight * pNext; passenger_t * pHead_passenger; //飞机包含乘客链表 int Goodlevel; //评估飞机的安全等级 int passengerNum; //保存航班的乘客总人数 int redNum; // int yellowNum;&#125;flight_t;typedef enum&#123; EN_GREEN, EN_YELLOW, EN_RED&#125;en_health_code;/* * function:create a flightHead * return:pHead_flight */flight_t * createFlight( void );/* * function:create a passengerHead * return:pHead_passenger * */passenger_t * createPassenger( void );//添加航班信息int addFlight(flight_t * pHead,int flight_id, const char * orig_city, const char * dest_city );//添加乘客信息int addPassenger( flight_t * pHead, int flight_id, char * name, char * id_card, int healthcode );int showPassenger( flight_t * pHead,int flight_id );void showFlight( flight_t * pHead);// function:计算某航班的风险值并返回int getRisk( flight_t * pHead, int flight_id );#endif flight.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include &quot;flight.h&quot;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;flight_t * createFlight( void )&#123; flight_t * pHead_flight = (flight_t * )malloc( sizeof( flight_t )); if ( NULL == pHead_flight ) &#123; return (flight_t *)0; &#125; memset( pHead_flight , &#x27;\\0&#x27; , sizeof( flight_t ) ); pHead_flight-&gt;flight_id = 0; pHead_flight-&gt;pNext = NULL; printf(&quot;create flight success\\r\\n&quot;); return pHead_flight;&#125;passenger_t * createPassenger( void )&#123; passenger_t * pHead_passenger = (passenger_t * )malloc( sizeof( passenger_t)); if ( NULL == pHead_passenger ) &#123; return ( passenger_t * )0; &#125; memset( pHead_passenger , &#x27;\\0&#x27; , sizeof( passenger_t ) ); printf(&quot;create passenger success\\r\\n&quot;); return pHead_passenger;&#125;int addFlight( flight_t * pHead, int flight_id, const char * orig_city, const char * dest_city )&#123; if ( NULL==pHead || flight_id &lt; 0 || NULL == orig_city || NULL == dest_city ) &#123; perror(&quot;param error!\\r\\n&quot;); return -1; &#125; flight_t * temp = (flight_t * )malloc( sizeof(flight_t )); memset(temp, &#x27;\\0&#x27;, sizeof(flight_t ) ); flight_t * pNew = (flight_t * )malloc( sizeof(flight_t )); memset( pNew , &#x27;\\0&#x27;, sizeof(flight_t ) ); //不能对空指针进行赋值， 要新 malloc pNew pNew-&gt;flight_id = flight_id; pNew-&gt;orig_city = orig_city; pNew-&gt;dest_city = dest_city; pNew-&gt;pHead_passenger =(passenger_t *)malloc( sizeof( passenger_t )); temp = pHead; while( temp-&gt;flight_id != flight_id &amp;&amp; temp-&gt;pNext != NULL ) //对，应该判断前一个，然后赋值好赋值 &#123; temp =temp-&gt;pNext; &#125; if (temp != NULL &amp;&amp; temp-&gt;flight_id == flight_id ) &#123; perror(&quot;flight already exist!, add error\\r\\n&quot;); return -1; &#125; temp-&gt;pNext= pNew; printf(&quot;add success\\r\\n&quot;); return 0;&#125;void showFlight( flight_t * pHead)&#123; if(NULL ==pHead) &#123; perror(&quot;param error!\\r\\n&quot;); return; &#125; flight_t* temp = pHead; while( temp != NULL ) &#123; // flight_id=0是头节点，可不打印 if( 0 == temp-&gt;flight_id ) &#123; temp = temp-&gt;pNext; &#125; printf(&quot;flight_id--%d 起始地点--%s, 目的地点--%s \\r\\n&quot;, temp-&gt;flight_id, temp-&gt;orig_city, temp-&gt;dest_city ); temp = temp-&gt;pNext; &#125; printf(&quot;show ok\\r\\n&quot;); return;&#125;int addPassenger( flight_t * pHead ,int flight_id, char * name, char * id_card, int healthcode ) &#123; if ( NULL == pHead || flight_id &lt;0 || NULL == name || NULL == id_card ) &#123; perror(&quot; param error\\r\\n&quot;); return -1; &#125; flight_t * ptmp = pHead; while ( ptmp-&gt;flight_id != flight_id ) &#123; ptmp = ptmp-&gt;pNext; if ( NULL == ptmp) &#123; perror(&quot; flight_id error!\\r\\n&quot;); return -2; &#125; &#125; passenger_t * pNew = ( passenger_t *)malloc( sizeof(passenger_t )); pNew-&gt;flight_id=flight_id; //0 green 1 yellow 2 red pNew-&gt;healthcode=healthcode; pNew-&gt;id_card = id_card; pNew-&gt;name = name; ptmp-&gt;passengerNum += 1; if( 2 == healthcode ) &#123; ptmp-&gt;redNum += 1; &#125; else if( 1 == healthcode ) &#123; ptmp-&gt;yellowNum += 1; &#125; passenger_t * pq = ( passenger_t *)malloc( sizeof(passenger_t )); pq = ptmp-&gt;pHead_passenger; while( pq-&gt;pNext != NULL) &#123; pq = pq-&gt;pNext; &#125; pq-&gt;pNext = pNew; return 0;&#125;int showPassenger( flight_t * pHead, int flight_id )&#123; if ( NULL == pHead || flight_id &lt; 0) &#123; perror(&quot; param error\\r\\n&quot;); return -1; &#125; flight_t * temp = pHead; // 用temp-&gt;pNext 做判断最后好赋值 while( temp-&gt;pNext != NULL &amp;&amp; temp-&gt;flight_id != flight_id ) &#123; temp = temp-&gt;pNext; &#125; if (temp-&gt;flight_id != flight_id &amp;&amp; temp-&gt;pNext == NULL) &#123; perror(&quot; flight_id error!\\r\\n&quot;); return -2; &#125; if (temp-&gt;flight_id == flight_id ) &#123; //passenger_t * pp = temp-&gt;pHead_passenger; 因为第一个是头节点，不打印 passenger_t * pp = temp-&gt;pHead_passenger-&gt;pNext; while ( pp != NULL) //遍历打印是 pp != NULL &#123; printf(&quot;passenger info:// name:%s, card_id:%s, healthcode:%d, flight_id:%d, origCity:%s, destCity:%s \\r\\n&quot;, pp-&gt;name,pp-&gt;id_card,pp-&gt;healthcode,pp-&gt;flight_id, temp-&gt;orig_city,temp-&gt;dest_city); pp=pp-&gt;pNext; &#125; &#125; return 0;&#125; int getRisk( flight_t * pHead, int flight_id )&#123; if ( NULL == pHead || flight_id &lt; 0 ) &#123; perror(&quot; param error!\\r\\n&quot;); return -1; &#125; flight_t * ptemp = pHead; while ( ptemp-&gt;flight_id != flight_id &amp;&amp; ptemp-&gt;pNext != NULL ) &#123; ptemp = ptemp-&gt;pNext; &#125; if ( ptemp-&gt;pNext == NULL &amp;&amp; ptemp-&gt;flight_id != flight_id) &#123; return -2; &#125; float redRisk =(float)ptemp-&gt;redNum / (float)ptemp-&gt;passengerNum; printf(&quot;passengerNum=%d, redNum=%d, yellowNum=%d\\r\\n&quot;,ptemp-&gt;passengerNum,ptemp-&gt;redNum, ptemp-&gt;yellowNum); printf(&quot;redRisk=%f\\r\\n&quot;, redRisk); if( 0 == redRisk) &#123; ptemp-&gt;Goodlevel = 0; printf(&quot;plane safe, take off\\r\\n&quot;); &#125; else if( redRisk &gt;= 0.1 ) &#123; ptemp-&gt;Goodlevel = 2; printf(&quot;dangerous!!!!stop \\r\\n&quot;); &#125; else if( redRisk &gt; 0 &amp;&amp; redRisk &lt; 0.1 ) &#123; ptemp-&gt;Goodlevel = 1; printf( &quot;just ok,but still need to be examine\\r\\n&quot; ); &#125; return 0;&#125; main.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &quot;flight.h&quot;int main(void)&#123; flight_t * pHead_flight = createFlight(); passenger_t * pHead_passenger = createPassenger(); addFlight(pHead_flight, 1, &quot;zhengzhou&quot;,&quot;xian&quot;); addFlight(pHead_flight, 2, &quot;beijing&quot;,&quot;xian&quot;); //addFlight(pHead_flight, 2, &quot;xinjiang&quot;,&quot;xian&quot;); addPassenger(pHead_flight,1,&quot;Jim&quot;, &quot;12345&quot;,0); addPassenger(pHead_flight,1,&quot;SU&quot;, &quot;sadw&quot;, 2); addPassenger(pHead_flight,1,&quot;zhang&quot;,&quot;334&quot;, 1); addPassenger(pHead_flight,1,&quot;li&quot;, &quot;888&quot;, 1); addPassenger(pHead_flight,1,&quot;q&quot;, &quot;812&quot;, 1); addPassenger(pHead_flight,1,&quot;s&quot;, &quot;833&quot;, 1); addPassenger(pHead_flight,1,&quot;qwd&quot;, &quot;124&quot;, 1); addPassenger(pHead_flight,1,&quot;trgh&quot;, &quot;oa9&quot;, 1); addPassenger(pHead_flight,1,&quot;dwew&quot;, &quot;wevc&quot;,1); addPassenger(pHead_flight,1,&quot;uh&quot;, &quot;okn&quot;, 1); addPassenger(pHead_flight,2,&quot;sfd&quot;, &quot;plm&quot;, 1); addPassenger(pHead_flight,2,&quot;yth&quot;, &quot;adv&quot;, 1); addPassenger(pHead_flight,2,&quot;sf&quot;, &quot;okq&quot;, 1); addPassenger(pHead_flight,2,&quot;alib&quot;, &quot;13df&quot;,1); addPassenger(pHead_flight,2,&quot;niuniu&quot;,&quot;asf3&quot;,1); addPassenger(pHead_flight,2,&quot;gui&quot;, &quot;qa1&quot;,1); addPassenger(pHead_flight,2,&quot;ww&quot;, &quot;qa2&quot;,1); addPassenger(pHead_flight,2,&quot;gg&quot;, &quot;qa3&quot;,1); addPassenger(pHead_flight,2,&quot;ym&quot;, &quot;qa4&quot;,1); addPassenger(pHead_flight,2,&quot;shui&quot;, &quot;qa5&quot;,1); addPassenger(pHead_flight,2,&quot;alp&quot;, &quot;ws5&quot;,1); addPassenger(pHead_flight,2,&quot;hub&quot;, &quot;sf6&quot;,0); getRisk( pHead_flight, 1); getRisk( pHead_flight, 2); showFlight( pHead_flight ); showPassenger(pHead_flight, 1); return 0;&#125; 运行效果参考：","categories":[],"tags":[{"name":"链表","slug":"链表","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"线程-linux","slug":"线程-linux","date":"2020-08-05T07:47:14.000Z","updated":"2020-08-10T11:22:21.447Z","comments":true,"path":"2020/08/05/线程-linux/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/05/%E7%BA%BF%E7%A8%8B-linux/","excerpt":"","text":"线程–轻量级进程 // 内核调度的最小单元为了进一步减少处理器的空转时间，支持多处理器，减少上下文切换开销 上下文切换：指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换，上下文切换过程中的信息被保存在进程控制块（PCB-Process Control Block）中 过程： ` [1]先挂起一个进程，把这个进程在cpu中的状态（上下文信息）存储在内存的 PCB 中 [2]在PCB中检索下一个进程的上下文并将其在CPU的寄存器中恢复 [3]跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行）并恢复该进程` linux中的线程依赖于 pthread 线程库 1、创建线程： pthread_create( pthread_t * thread, pthread_attr_t *attr,void *( *start_routine)(void *), void * arg); thread: 线程标识符 attr: 线程属性设置， NULL 表示缺省属性 start_routine: 线程执行函数，参数和返回值都是 void * arg: 传递给 线程执行函数用的参数 return: success:0 error:错误码 2、退出线程: pthread_exit( void * retval ); retval: 线程结束时的返回值， 可以通过 pthread_join() 来接收//但是使用中不能用 exit 退出线程，因为一般一个进程中包含多个线程，exit的作用是使当前进程终止，进程中所以线程都会over—所以退出线程用 pthread_exit() 来替代 线程主动结束：可以调用 pthread_exit() 一个线程终止另外一个线程： 调用 pthread_cancel() 实现// 在被取消的线程内部要 先调用 pthread_setcancel() 和 pthread_setcanceltype() 设置相应的取消状态 3、pthread_join() 以阻塞的方式等待 thread 指定的线程结束，函数返回时，被等待线程的资源被回收，如果线程已经结束，该函数会立即返回 resutn: success:0 error:错误号 函数原型： pthread_join( pthread_t pthread, void ** thread_result ); thread:被等待线程的标识符 thread_result: 用户定义的指针，用来接收被等待线程结束时的返回值（如果返回不为NULL） **为什么是二级指针：**原因：一级指针只能用来改变指向内存的值，传递的就是指针p内存的地址,所以修改它就是修改了它自己的指向; 4、pthread_cancel( pthread_t thread ) thread: 要取消的线程的 标识符 return: success:0 error:错误码 线程函数使用 Demo // 编译的时候需要链接 pthread thread.h #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #define THREAD_NUM 3 // 线程数 #define REPEAT_TIMES 5 //每个线程中的循环次数限制 #define DELAY_TIME 6.0 //循环之间的最大时间间隔 线程处理函数 void * thread_function( void * arg){ int thread_num = (int )arg; //线程总数 int delay_time = 0; //延时 int count = 0; //计调用次数 printf(&quot;thread %d start!\\r\\n&quot;,thread_num); for (count=0;count&lt;REPEAT_TIMES; count++ ) &#123; delay_time = (int)( rand() * DELAY_TIME / (RAND_MAX) ) +1 ; sleep( delay_time ); //随机等待1--6 s, 模拟任务完成的时间随机 printf(&quot;Thread %d :job %d delay = %d\\r\\n&quot;, thread_num,count, delay_time); &#125; printf(&quot;Thread %d is finished\\r\\n&quot;, thread_num); pthread_exit(NULL); //任务完成自行结束 } main.c #include “thread.h” int main( void ){ pthread_t thread[THREAD_NUM]; //定义存放 thread 号的类型数组 int no = 0,res; void * thread_ret; srand( time( NULL )); //埋下时间种子 for( no=0; no&lt;THREAD_NUM; no++) &#123; res = pthread_create(&amp;thread[no], NULL, thread_function, (void*)no ); //创建的时候是 pthread_t * // no 标识是第几个线程 if ( res != 0 ) //create error &#123; printf(&quot;Create thread %d error\\r\\n&quot;, no); exit(res); // 结束进程， &lt;stdlib.h&gt; 参数不为0都异常 &#125; &#125; printf(&quot;Create threads success!\\r\\n&quot;); for( no=0;no&lt;THREAD_NUM;no++) &#123; // pthread_join: pthread_t thread res = pthread_join( thread[no], &amp;thread_ret); //阻塞式等待线程退出 //param_2 被等待线程结束的返回值, void ** thread_result if ( 0 == res ) //success:0 error:错误号 &#123; printf(&quot;Thread %d joined\\r\\n&quot;,no); &#125; else &#123; printf(&quot;Thread %d joined failed\\r\\n&quot;, no); &#125; &#125; return 0; } 运行情况：","categories":[{"name":"多进程/线程","slug":"多进程-线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"进制间转换","slug":"进制间转换","date":"2020-08-04T11:08:07.000Z","updated":"2020-08-10T11:22:23.239Z","comments":true,"path":"2020/08/04/进制间转换/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/04/%E8%BF%9B%E5%88%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"&lt;10进制—&gt;2进制&gt; 1234567ex: 19---&gt; 19 / 2 = 9....1 9 / 2 = 4....1 4 / 2 = 2....0 2 / 2 = 1....0 1 / 2 = 0....1 反序取余数 10011 10进制中的 小数部分–&gt;2进制 1234ex: 0.75小数不断×2取整，直到没有小数为止，注意:不是所有的小数都可以转为 2 进制 0.75 * 2 = 1.5 取整 1 0.5 * 2 = 1 顺序取数得: 0.11 &lt;16进制—-&gt; 10进制 &gt; 123456716进制 是 16 进 1 0 1 2 3 4 5 6 7 8 9 A(10) B C D E F(15)ex: 2AF5 = 5* 16^0 + F*16^1 + A*16^2 + 2*16^3 = 5 + 15*16 + 10*256 + 2*4096 = 5 + 240 + 2560 + 8192 = 10997 &lt;10进制 —-&gt; 16进制&gt; 1234567余数定理分解ex： 48774877 / 16 = 304....13 304 / 16 = 19....0 19 / 16 = 1.....3 1 / 16 = 0.....1 结果 = 130D (注意顺序)","categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"stm32-port1","slug":"stm32-port1","date":"2020-08-04T04:37:50.000Z","updated":"2020-08-04T04:37:50.998Z","comments":true,"path":"2020/08/04/stm32-port1/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/04/stm32-port1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-08-02T19:39:29.453Z","updated":"2020-08-10T08:09:40.010Z","comments":true,"path":"2020/08/03/hello-world/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/03/hello-world/","excerpt":"","text":"欢迎来到 NiuNiu 的技术经验分享博客网站但凡流行的工具、技术，都是入门易，精通难，想有所成就，都需要不懈的努力和漫长的积累，愿诸君与我共勉！不缺拳打世界的勇气,亦有归去风雨无晴的洒脱，~-Z","categories":[],"tags":[]},{"title":"单向不循环链表","slug":"单向不循环链表","date":"2020-08-01T16:48:16.000Z","updated":"2020-08-07T09:58:15.778Z","comments":true,"path":"2020/08/02/单向不循环链表/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/02/%E5%8D%95%E5%90%91%E4%B8%8D%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/","excerpt":"","text":"链表： 动态的数据结构，分为数据域和指针域， 动态进行存储分配，实现数据增删 优点： ​ 1、存储空间动态分配，可以根据实际需要使用 ​ 2、不需要地址连续的存储空间 ​ 3、插入/删除操作只需通过修改指针实现，不必移动数据元素， 操作时间效率高 ，插入删除事件复杂度 O(1) 缺点： ​ 1、每个链节点需要设置指针域（ 存储密度小 ） ​ 2、是一种非随机存储结构，查找/定位等操作都需要顺序扫描链表实现，时间效率低 O(n) [TOC] Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258/* 头节点:数据域为空 头节点:数据域为空 malloc 申请 &lt;malloc.h&gt; memset 初始化 &lt;string.h&gt;*/typedef int datatype; typedef struct link&#123; datatype data; struct link * pNext;&#125;Link;// 枚举 中间用, 未赋值默认第一个为0enum opt&#123; ERR=-1, OK, TAIL=-1, HEAD,&#125;;// [1]创建链表---即生成头节点Link * createLink(void);Link * createLink(void)&#123; Link * pHead =NULL; pHead=(Link *)malloc(sizeof(Link)); if(NULL==pHead) &#123; return NULL; &#125; memset(pHead,&#x27;\\0&#x27;,sizeof(Link)); return pHead;&#125;// [2]插入节点---头插，尾插，中间插//根据位置给链表添加节点//参数：链表首地址，要添加的元素，和插入的位置//HEAD=0 TAIL=-1 其他中间//返回值 成功 OK 失败 ERRint InsertLink(Link * pHead, datatype item,int offset);int InsertLink(Link * pHead, datatype item,int offset)&#123; if(NULL==pHead) &#123; return ERR; &#125; int k=0; Link * pNew=NULL; Link * pTmp=pHead; //如果写pHead-&gt;pNext要判断是否为空所以为了方便写pHead pNew=(Link *)malloc(sizeof(Link)); if(NULL==pNew) &#123; return ERR; &#125; pNew-&gt;data=item; pNew-&gt;pNext=NULL; switch(offset) &#123;case HEAD: pNew-&gt;pNext=pHead-&gt;pNext; pHead-&gt;pNext=pNew; break;case TAIL: while(pTmp-&gt;pNext!=NULL) &#123; pTmp=pTmp-&gt;pNext; &#125; pTmp-&gt;pNext=pNew; break;default: while(k &lt; offset-1 &amp;&amp; pTmp != NULL) //pTmp!=NULL说明找到插入位置，如果pTmp==NULL,表示未找到要free(pNew)再返回报错 &#123; k++; pTmp=pTmp-&gt;pNext; &#125; if(pTmp==NULL) //先判断是否为空 &#123; free(pNew); return ERR; &#125; pNew-&gt;pNext=pTmp-&gt;pNext; pTmp-&gt;pNext=pNew; break; &#125;&#125;// [3]打印输出---遍历int show(Link * pHead);int show(Link * pHead)&#123; if(NULL==pHead) &#123; return ERR; &#125; Link * pTmp=pHead-&gt;pNext; while(pTmp!=NULL) &#123; printf(&quot; %d &quot;,pTmp-&gt;data); pTmp=pTmp-&gt;pNext; &#125; printf(&quot;\\n&quot;);&#125;// [4]删除节点----头删，尾删，中间删int DeleteLink(Link * pHead,int offset,datatype * pData);int DeleteLink(Link * pHead,int offset,datatype * pData)&#123; if(NULL==pHead||NULL==pData) &#123; return ERR; &#125; Link * pDel=NULL; Link * pPre=NULL; int k=0; switch(offset) &#123; case HEAD: pDel=pHead-&gt;pNext; if(pDel==NULL) //一定要判断 &#123; *pData=0; printf(&quot;链表为空！\\n&quot;); return ERR; &#125; pHead-&gt;pNext=pDel-&gt;pNext; //先将删除的数保存 *pData=pDel-&gt;data; free(pDel); pDel=NULL; break; case TAIL: pPre=pHead; pDel=pHead-&gt;pNext; if(pDel==NULL) //说明没有什么删除的，空链表是pHead-&gt;pNext为空 &#123; printf(&quot;链表为空!\\n&quot;); *pData=0; return ERR; while(pDel-&gt;pNext!=NULL) &#123; pPre=pDel; pDel=pDel-&gt;pNext; &#125; //保存删除的数据v *pData=pDel-&gt;data; free(pDel); pDel=NULL; //把pre变成尾节点 pPre-&gt;pNext=NULL; break; &#125; default: pPre=pHead; pDel=pHead-&gt;pNext; k=0; while(k&lt;offset-1&amp;&amp;pDel!=NULL) &#123; k++; pPre=pDel; //是pPre=pDel;; pDel=pDel-&gt;pNext; &#125; if(pDel==NULL) &#123; printf(&quot;链表为空!\\n&quot;); *pData=0; return ERR; &#125; *pData=pDel-&gt;data; pPre-&gt;pNext=pDel-&gt;pNext; free(pDel); pDel=NULL; break; &#125;&#125;// [5]销毁链表Link * Destroy(Link * pHead);Link * Destroy(Link * pHead)&#123; if(NULL==pHead) &#123; return NULL; &#125; Link * pDel=NULL; //while(pDel!=NULL) //while(1)是死循环 永远成立； while(1) &#123;//找到链表中的首节点 pDel=pHead-&gt;pNext; if(pDel==NULL) &#123; break; &#125; //保护好首节点后的所有节点 pHead-&gt;pNext=pDel-&gt;pNext; //释放首节点 free(pDel); pDel=NULL; &#125; //最后再释放头节点 free(pHead); pHead=NULL; printf(&quot;链表已删除\\n&quot;); return pHead; //一定要返回 pHead 否则会错误&#125;// [6]链表逆序---拓展int Negative(Link * pHead); //Negative sequence 逆序int Negative(Link * pHead) //Negative sequence 逆序&#123; if(NULL==pHead) &#123; return ERR; &#125; Link * pA=NULL; Link * pB=NULL; pA=pHead-&gt;pNext; //保护好头节点后的所有节点 //原链表变为空链表 pHead-&gt;pNext=NULL; //保护好首节点后的所有节点 while(1) &#123; pB=pA-&gt;pNext; //首节点插入到新链表 pA-&gt;pNext=pHead-&gt;pNext; pHead-&gt;pNext=pA; pA=pB; if(pA==NULL) &#123; break; &#125; &#125; &#125; test1234int main()&#123; return 0;&#125; int main()","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E9%93%BE%E8%A1%A8/"}]}],"categories":[{"name":"生产者消费者demo","slug":"生产者消费者demo","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85demo/"},{"name":"进程线程","slug":"进程线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"},{"name":"多进程/线程","slug":"多进程-线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"},{"name":"编程基础","slug":"编程基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"有名管道","slug":"有名管道","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93/"},{"name":"有名管道，信号量","slug":"有名管道，信号量","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"线程bug","slug":"线程bug","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8Bbug/"},{"name":"信号量","slug":"信号量","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"线程通信","slug":"线程通信","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"},{"name":"链表","slug":"链表","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"线程","slug":"线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"基础","slug":"基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E5%9F%BA%E7%A1%80/"}]}