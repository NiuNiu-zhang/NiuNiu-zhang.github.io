{"meta":{"title":"NiuNiu","subtitle":"IT_小马哥","description":"NiuNiu的学习博客","author":"Zhang  Hao","url":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io","root":"/"},"pages":[],"posts":[{"title":"Boa服务器和cgi","slug":"Boa服务器和cgi","date":"2020-08-12T10:45:48.000Z","updated":"2020-08-12T11:03:17.843Z","comments":true,"path":"2020/08/12/Boa服务器和cgi/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/12/Boa%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8Ccgi/","excerpt":"","text":"描述：boa是基于 http 的单任务小型服务器 大小只有 60KB 左右只能依次 完成用户的请求， 而不会 fork 出新的进程 来处理并发连接请求 CGI 只是一个进程，用来 提供接口 –&gt;自动目录生成 和 自动文件进行拼接可靠性，可移植性 服务器模型C-Sclient：张三- id1，李四- id2server：腾讯1、先登录 输入账号密码 发送服务器验证2、向 李四 发送消息封装信息包&lt;id1 数据 id2&gt;3、服务器 先查找是否有 李四然后把 数据包发给 李四4、李四发给张三&lt;id2 数据 id1&gt; 类比 ： &lt;boa 服务器的作用&gt;CGI— 相当于 客户端1Web—相当于 客户端2①查找 CGI 查找 Web②把 CGI 数据提取出来—&gt;交给对应的网页—&gt;显示 boa.conf 保存的配置信息是从哪里查找到 哪里显示&lt;cgi.bin&gt; 查找：写入配置文件 boa.conf从 boa.bin 查找 关闭 boa 服务器先查找 进程号 ps -axj | grep “boa”kill -9 pid号注意：boa 模块在 该项目上层应用中 是基石组成 boa环境搭建和测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;源码下载&gt;http://www.boa.org/ （项目版本 0.94.13） boa-0.94.13.tar.gzcd 到对应目录 解压 tar xzf boa-0.94.13.tar.gz安装需要的工具 bison flex sudo apt-get update sudo apt-get install bison flex 生成 Makefile 文件 cd boa-0.94.13/src 执行 ./configure 准备工作 Boa 需要在 /etc 目录下建立一个 boa 目录 里面存放 Boa 的主要配置文件 boa.conf 新建目录 sudo mkdir /etc/boa 《在家目录下 /home/linux》 cd ~ 返回根目录 cd /etc 切换当前目录 sudo cp ~/Desktop/boa-0.94.13/boa.conf boa 《复制文件boa.conf到/etc/boa目录》 修改 boa.conf 配置文件 《管理员身份》 sudo gedit ~/etc/boa/boa.conf (1)Group的修改 修改 Group nogroup 为 Group 0 (2)user的修改 修改 User nobody 为 User 0 (3)修改ScriptAlias的路径 修改ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/ 为 ScriptAlias /cgi-bin/ /var/www/cgi-bin/ (4)去掉ServerName前面的注释符号# 修改#ServerName www.your.org.here 为 ServerName www.your.org.here 否则会出现错误: &quot;gethostbyname::No such file or directory&quot; (5)注释掉AccessLog命令 修改AccessLog /var/log/boa/access_log 为# AccessLog /var/log/boa/access_log 否则会出现错误提示: &quot;Cannot open ... for logging:logfile open:Is a directory&quot; &lt;修改 src/compat.h&gt; #define TIMEZONE_OFFSET(foo) foo##-&gt;tm_gmtoff 修改成 #define TIMEZONE_OFFSET(foo) (foo)-&gt;tm_gmtoff 否则会出现错误：util.c:100:1: error: pasting &quot;t&quot; and &quot;-&gt;&quot; does not give a valid preprocessing token make: *** [util.o] 错误 1 &lt;修改 src/log.c&gt; if (dup2(error_log, STDERR_FILENO) == -1) &#123; DIE(&quot;unable to dup2 the error log&quot;); &#125; 修改为 /*if (dup2(error_log, STDERR_FILENO) == -1) &#123; DIE(&quot;unable to dup2 the error log&quot;); &#125;*/ 否则会出现错误：log.c:73 unable to dup2 the error log:bad file descriptor &lt;修改 src/boa.c&gt; if (setuid(0) != -1) &#123; DIE(”icky Linux kernel bug!”); &#125; 修改为 #if 0 if (setuid(0) != -1) &#123; DIE(”icky Linux kernel bug!”); &#125; #endif 否则可能会出现错误：boa.c:228 、 boa.c:226 boa 目录搭建完成之后开始进行 web 服务器的文件根目录创建 1234567891011121314151617181920212223242526272829303132返回根目录 cd ~ sudo mkdir /var/www 创建目录 sudo chmod -R 777 /var/www 修改权限 【创建log目录】 sudo mkdir /var/log/boa sudo mkdir /var/log/boa/error_log sudo mkdir /var/log/boa/access_log sudo chmod -R 777 /var/log/boa 修改权限 sudo chmod -R 777 /var/log/boa/error_log 修改权限 sudo chmod -R 777 /var/log/boa/access_log 修改权限 【创建 cgi 目录·】 sudo mkdir /var/www/cgi-bin 创建cgi文件存放目录 sudo chmod -R 777 /var/www/cgi-bin 修改权限 在 src 目录下 编译 cd ~ 返回根目录 cd Destop/boa-0.94.13/src 切换目录 make 编译 在 src 目录下 运行boa sudo ./boa 必须在src目录下运行 查看进程 ps -e 看boa是否已经运行 网页测试 浏览器访问：http://127.0.0.1 注意：默认端口是80，如果你的80端口已经被占用，可以修改/etc/boa/boa.conf，变更Port 80。这里对应修改：http://127.0.0.1:端口号 【cgi 程序测试】 将Destop/boa-0.94.13/examples目录下的cgi-test.cgi拷贝到var/www/cgi-bin 浏览器访问：http://127.0.0.1/cgi-bin/cgi-test.cgi（现在你可以删掉boa-0.94.13.tar.gz，然后把解压后的目录boa-0.94.13放到你自己想放的地方，但是每次运行boa自己要容易找到位置。） cgi: &lt;CGI—又叫 通用网关接口 &gt;是 Web 服务器运行时外部程序的规范，按 CGI 编写的程序可以拓展服务器功能CGI 应用程序能与浏览器进行交互，还可通过数据API与数据库服务器等外部数据源进行通信，从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。 A-9 —&gt;CGI—&gt;BOA—&gt;HTML网页发控制表单—–&gt;CGI—&gt;相应的cgi进程控制硬件 c 和 HTML 语言有一个交互这是c与cgi的数据交互： .c–&gt;,cgi其实 cgi 就是app只是cgi提供了 c 和 html 的超文本协议的交互 CGI程序的工作一般流程就是 ①接收表单数据进行数据处理，最后根据处理结果生成新的页面 返回给浏览器 表单一般用 POST 方法提交给服务器，由CGI程序获得 程序根据 元素名字/值 中的元素名字来区分数据， 完成数据处理后，再读取相应的模板文件， 根据注释标记和对应的数据填充到 HTML 文本中，生成最后页面返回给浏览器","categories":[{"name":"项目技术栈","slug":"项目技术栈","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E6%A0%88/"}],"tags":[{"name":"boa","slug":"boa","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/boa/"}]},{"title":"初识JSON","slug":"初识JSON","date":"2020-08-12T06:17:09.000Z","updated":"2020-08-12T11:03:18.915Z","comments":true,"path":"2020/08/12/初识JSON/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/12/%E5%88%9D%E8%AF%86JSON/","excerpt":"","text":"JSON:指的是 javaScript 对象表示法，一种基于文本，独立于语言的轻量级数据交换格式JSON是存储和交换文本信息的语法， 类似 XML，但比 XML 更小、更快、更易解析JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。 1234567891011121314151617181920212223242526272829303132333435JSON 对象在 大括号 &#123;&#125;中书写， 对象可以包含多个 名称/值对&#123;&quot;name&quot;:&quot;goole&quot;, &quot;url&quot;:&quot;www.goole1.com&quot;&#125;JSON 数组在中括号 [] 中书写，数组可包含多个对象[&#123;&quot;城市&quot;:&quot;福州&quot;&#125;,&#123;&quot;城市&quot;:&quot;厦门&quot;&#125;,&#123;&quot;城市&quot;:&quot;平潭&quot;&#125;]JSON 的布尔值 可以是 true 或者 false， json 可以设置 null 值&#123;&quot;flag&quot;:true&#125; &#123;&quot;属性&quot;:null&#125;JSON 对象使用在大括号(&#123;&#125;)中书写。对象可以包含多个 key/value（键/值）对。key必须是字符串，value可以是合法的JSON数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。key 和 value 中使用冒号(:)分割。每个 key/value 对使用逗号(,)分割。```c环境配置：// 由于C语言本身不支持JSON数据，所以我们可以通过cJSON使得C语言支持JSON格式的数据。cJSON作为Json格式的解析库，其主要功能是构建和解析Json报文，``` ccJSON结构体typedef struct cJSON &#123; struct cJSON *next,*prev; struct cJSON *child; int type; char *valuestring; int valueint; double valuedouble; char *string; &#125; cJSON; 1.cJSON存储的时候是采用链表存储的，其访问方式很像一颗树。每一个节点可以有兄妹节点，通过next/prev指针来查找，它类似双向链表；每个节点也可以有孩子节点，通过child指针来访问，进入下一层。不过，只有节点是对象或数组才可以有孩子节点。2.type一共有7种取值，分别是：#define cJSON_False 0#define cJSON_True 1#define cJSON_NULL 2#define cJSON_Number 3#define cJSON_String 4#define cJSON_Array 5#define cJSON_Object 6 3、string中存放的是这个节点的名字。 cJSON 库的使用下载 http://sourceforge.net/projects/cjson/ cJSON，目前来说，就只有两个文件，一个cJSON.c 一个cJSON.h文件。用法：只需在函数中includecJSON.h头文件，然后和cJSON.c或库文件libcJSON.a一起编译即可使用。在linux上，使用命令进行编译：gcc cJSON.c test.c -o test -lm 使用的时候需要链接 库 -lm 重要函数说明：1、 创建创建 JSON 对象： cJSON * cJSON_CreateObject( void );创建 JSON 数组: cJSON * cJSON_CreateArray( void );2、添加【向对象中添加】void cJSON_AddItemToObject(cJSON * object, const char * string, cJSON * item );【向数组中添加】void cJSON_AddItemToArray( cJSON * array, cJSON * item ); 【向对象中增加数字】cJSON_AddItemToObject(root, “value”, cJSON_CreateNumber(value));【向对象中增加文件】cJSON_AddItemToObject(root, “string”, cJSON_CreateString(string)); demo: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &quot;cJSON.h&quot;// 创建一个数组，并向数组添加 一个字符串 和一个数字int create_js(void)&#123; cJSON *root = NULL; root = cJSON_CreateArray(); cJSON_AddItemToArray(root, cJSON_CreateString(&quot;Hello world&quot;)); cJSON_AddItemToArray(root, cJSON_CreateNumber(2019)); //char *s = cJSON_PrintUnformatted(root); char *s = cJSON_Print(root); if(s) &#123; printf(&quot; %s \\n&quot;,s); free(s); &#125; if(root) cJSON_Delete(root); return 0;&#125; //创建一个对象，并向这个对象里添加字符串和整形键值int main( int argc, char * argv[] )&#123; cJSON * usr = NULL; //创建根数据对象 usr = cJSON_CreateObject(); // 加入键值，加 字符串 cJSON_AddStringToObject(usr,&quot;name&quot;,&quot;jack-hui&quot;); cJSON_AddStringToObject(usr,&quot;age&quot;,&quot;20&quot;); cJSON_AddStringToObject(usr,&quot;job&quot;,&quot;c&quot;); // 加入整数 cJSON_AddNumberToObject(usr,&quot;num&quot;,123); // 将 json 形式 打印成正常的 字符串形式 char * out = cJSON_Print( usr ); printf(&quot;%s\\r\\n&quot;, out ); // 释放内存 cJSON_Delete( usr ); free( out ); create_js(); return 0;&#125; 12345678910111213141516171819202122232425262728293031int create_js(void)&#123; cJSON *root = NULL; cJSON *js_body = NULL; cJSON *js_list = NULL; root = cJSON_CreateObject(); cJSON_AddItemToObject(root,&quot;最外层&quot;,js_body = cJSON_CreateObject()); cJSON_AddItemToObject(js_body,&quot;Rule&quot;,js_list = cJSON_CreateObject()); cJSON_AddStringToObject(js_list,&quot;name&quot;,&quot;xiaoming&quot;); cJSON_AddStringToObject(js_body,&quot;enable&quot;,&quot;true,false&quot;); cJSON_AddNumberToObject(js_list,&quot;age&quot;,20); char *s = cJSON_Print(root); //char *s = cJSON_PrintUnformatted(root); if(s) &#123; printf(&quot; %s \\n&quot;,s); free(s); &#125; if(root) cJSON_Delete(root); return 0;&#125;int main(int argc, char **argv)&#123; create_js(); return 0;&#125;","categories":[{"name":"JSON","slug":"JSON","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/JSON/"}],"tags":[]},{"title":"json报文解析","slug":"json报文解析","date":"2020-08-12T01:51:53.000Z","updated":"2020-08-12T11:03:19.812Z","comments":true,"path":"2020/08/12/json报文解析/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/12/json%E6%8A%A5%E6%96%87%E8%A7%A3%E6%9E%90/","excerpt":"","text":"json：通常用于与 服务端交换数据，接收服务器数据时一般是字符串 解析 json 字符串：1、cJSON_Parse() 函数&ensp; &ensp; 负责解析 json 数据包，并按照 cJSON 结构体的结构序列化整个数据包，使用该函数会通过 malloc 在内存中开辟空间，使用完需要手动释放2、cJSON_GetObjectItem() 函数可以从 cJSON 结构体中查找某个子节点名称（键名称），如果查找成功，可把该子节点序列化到 cJSON 结构体中 3、如果需要使用cJSON结构体内容，通过cJSON结构体中的 valueint 和 valuestring 取出有价值的内容4、cJSON_Delete 释放内存空间 序列化：Serialization是将对象的状态信息 转换为可以存储或传输形式的过程在序列化期间，兑奖将其当前状态写入到临时或持久性存储区，以后可以通过从存储区中读取或反序列化对象的状态，重新创建该对象 demo: 创建 json, 从 json 中获取数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;cJSON.h&quot;char * makejson()&#123; cJSON * pJsonRoot = NULL; //定义根节点 pJsonRoot = cJSON_CreateObject(); if ( NULL == pJsonRoot) &#123; perror(&quot;create object error!\\r\\n&quot;); return NULL; &#125; cJSON_AddStringToObject( pJsonRoot,&quot;hello&quot;, &quot;hello world&quot;); cJSON_AddNumberToObject( pJsonRoot,&quot;number&quot;, 10010); cJSON_AddBoolToObject( pJsonRoot,&quot;bool&quot;, 1); cJSON * pSubJson = NULL; pSubJson = cJSON_CreateObject(); if ( NULL == pSubJson ) &#123; // 删除掉原来的 root cJSON_Delete( pJsonRoot ); return NULL; &#125; cJSON_AddStringToObject( pSubJson, &quot;subjsonobj&quot;,&quot;a sub json string&quot;); cJSON_AddItemToObject( pJsonRoot, &quot;subobj&quot;, pSubJson ); //往root 里加入 pSubJson char * p = cJSON_Print( pJsonRoot ); //将 json 形式打印成正常的字符串 格式 if (NULL == p) &#123; cJSON_Delete( pJsonRoot ); return NULL; &#125; cJSON_Delete( pJsonRoot ); return p;&#125;void parseJson( char * pMsg ) //parse:分析，描述&#123; if ( NULL == pMsg) &#123; perror(&quot;param error!\\r\\n&quot;); return ; &#125; cJSON * pJson = cJSON_Parse( pMsg); //parse 解析接口,解析之后是cJSON * 格式 if ( NULL == pJson ) &#123; perror(&quot;parse error!\\r\\n&quot;); return ; &#125; // get string from json cJSON * pString = cJSON_GetObjectItem(pJson, &quot;hello&quot;); if ( NULL == pString ) &#123; perror(&quot;get string error!\\r\\n&quot;); return; &#125; printf(&quot;obj_1:%s\\r\\n&quot;,pString-&gt;valuestring); cJSON * pNum = cJSON_GetObjectItem(pJson, &quot;number&quot;); if (NULL == pNum) &#123; perror(&quot;get num error!\\r\\n&quot;); return ; &#125; printf(&quot;obj_2:%d\\r\\n&quot;,pNum-&gt;valueint); cJSON * pBool = cJSON_GetObjectItem( pJson, &quot;bool&quot;); if (NULL == pBool) &#123; perror(&quot;get bool error!\\r\\n&quot;); return ; &#125; printf(&quot;obj_3:%d\\r\\n&quot;,pBool-&gt;valueint); cJSON * pSub = cJSON_GetObjectItem( pJson,&quot;subobj&quot;); if ( NULL == pSub) &#123; perror(&quot;get sub error!\\r\\n&quot;); return; &#125; cJSON * pSubSub = cJSON_GetObjectItem( pSub,&quot;subjsonobj&quot;); if( NULL== pSubSub) &#123; perror(&quot;get subsub error!\\r\\n&quot;); return ; &#125; printf(&quot;sub_obj_sub:%s\\r\\n&quot;,pSubSub-&gt;valuestring); cJSON_Delete( pJson);&#125;int main()&#123; char * p = makejson(); if ( NULL == p) &#123; perror(&quot; makejson error!\\r\\n &quot; ); return -1; &#125; printf(&quot;%s\\r\\n&quot;, p); parseJson(p); free(p); //千万不要忘记释放内存呀，cJSON_Print()函数或者cJSON_PrintUnformatted（）产生的内存，使用free(char *)进行释放 return 0;&#125; 运行： 创建 jsonArray ，从json数组中解析数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;cJSON.h&quot;//创建数组，数组值是另一个JSON的item，这里使用数字作为演示char * makeArray( int size )&#123; cJSON * root = cJSON_CreateArray(); if (NULL == root) &#123; printf(&quot;create json array faild\\n&quot;); return NULL; &#125; int i=0; for (i=0;i&lt;size;i++) &#123; cJSON_AddNumberToObject(root, &quot;heh&quot;, i); &#125; char * out = cJSON_Print(root); cJSON_Delete(root); return out;&#125;// 解析创建好的 cJSON 数组void parseArray( char * pJson)&#123; if (NULL == pJson ) &#123; perror(&quot;param error!\\r\\n&quot;); return ; &#125; cJSON * root = NULL; if ( NULL == (root = cJSON_Parse(pJson)) ) //解析创建好的 &#123; perror(&quot;parseArray error!\\r\\n&quot;); return ; &#125; int size = cJSON_GetArraySize( root ); // cJSON_GetArraySize int icnt = 0; for (icnt=0; icnt&lt;size; icnt ++ ) &#123; cJSON * pSub = cJSON_GetArrayItem( root, icnt ); //cJSON_GetArrayItem if ( NULL == pSub ) &#123; continue; //退出本次循环，执行下一次循环 &#125; int value = pSub-&gt;valueint; printf(&quot;value[%2d]:[%d]\\r\\n&quot;,icnt, value ); &#125; cJSON_Delete( root ); return;&#125;int main()&#123; char * json = makeArray(7); if ( NULL == json) &#123; perror(&quot;makeArray error!\\r\\n&quot;); return -1; &#125; printf(&quot;%s\\r\\n&quot;, json); parseArray(json); free(json); return 0;&#125; 运行：","categories":[{"name":"JSON","slug":"JSON","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/JSON/"}],"tags":[{"name":"人脸识别技术栈","slug":"人脸识别技术栈","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"进程间通信-管道","slug":"管道","date":"2020-08-10T08:10:45.000Z","updated":"2020-08-12T11:03:21.346Z","comments":true,"path":"2020/08/10/管道/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/10/%E7%AE%A1%E9%81%93/","excerpt":"","text":"Linux 进程间通讯 ：1、无名管道2、有名管道3、信号4、消息队列5、共享内存6、信号量7、套接字 什么是管道？ &ensp; &ensp; &ensp; 管道是一个进程连接数据流到另一个进程的通道，通常的作用是把一个进程的输出通过管道连接到另一个进程的输入分为：有名管道 pipe 和 无名管道 fifo 管道操作： &ensp; &ensp; &ensp; 一个进程往管道中写入数据，另一个进程从管道中读出数据 有名管道特点：①先进先出，对管道及 FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾， 有名管道不支持 如 lseek() 等文件定位操作。②又称为 FIFO 文件，有名管道一旦创建完成后，linux会创建一个文件，对文件进行读写，就实现进程间的 数据通信 了。③可以使 互不相关的 两个进程实现彼此通信注意：FIFO 文件只能以 RDONLY 的方式读取打开 或者 WRONLY 的方式写打开FIFO 中的内容被读取后，就消失了，但是普通文件内容读取后不会消失对有名管道的操作可以用常规的 文件 IO 操作：1—-&gt; 创建有名管道 123456789101112131415161718192021222324#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt; int mkfifo(const char *pathname, mode_t mode) //mknod //pathname:要创建的FIFO文件名(带路径) //mode :创建的文件的权限 0777 可读可写可执行 0666 读写 //EEXIST 代表文件已经存在的错误码 demo if ( ( mkfifo( MYFIFO, O_CREAT | O_EXCL) &lt; 0 ) &amp;&amp; ( errno != EEXIST )/* or mknod*/ ) &#123; printf(&quot;create fifo error!\\r\\n&quot;); return errno; //返回错误码 EAGAIN 宏从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。例如，以 O_NONBLOCK的标志打开文件/socket/FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。demo if ( -1 == (real_read = read(fd, read_buffer, UNIT_SIZE ))) &#123; if (errno == EAGAIN ) &#123; printf(&quot;No data yet\\r\\n&quot;); &#125; &#125; &#125; return: success: FIFO的文件描述符 error: -12—-&gt; 删除有名管道 123#include &lt;unistd.h&gt; int unlink(const char *pathname) return: success:0 error: -1 3—-&gt; 示例使用一个存在的有名管道之前，需要用open（）将其打开。因为有名管道是一个存在于硬盘上的文件，而管道是存在于内存中的特殊文件。以下程序演示有名管道在无亲缘关系的进程之间如何通信。 12345678910void main()&#123; int fd; char * p =&quot;weiqi7777 world\\r\\n&quot;; mkfifo(&quot;fifo.txt&quot;, 0777); fd = open(&quot;fifo.txt&quot;, O_WRONLY); //写 write(fd,p, strlen(p)+1); //strlen的话不计算 \\n， sizeof计算 close(fd);&#125; 注意：有名管道必须用于两进程，一写一读，只写不读会卡在那里，阻塞demo：write.c 123456789101112131415161718192021222324252627282930313233343536//有名管道 fifo 的写端代码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#define FIFO_NAME &quot;myfifo&quot;#define BUF_SIZE 1024int main( void )&#123; int fd; char buf[BUF_SIZE] = &quot;Hello procwrite, I come from process named procread!&quot;; // 因为不知道 谁会操作，修改权限掩码 umask( 0 ); //指明创建一个有名管道且存取权限为0666，即创建者、与创建者同组的用户、其他用户对该有名管道的访问权限都是可读可写 if ( mkfifo( FIFO_NAME, 0666) == -1 ) //mknod &#123; perror(&quot;mkfifo error\\r\\n&quot;); exit(1); // 0是正常，其他异常退出 &#125; if ( -1 == ( fd = open(FIFO_NAME, O_WRONLY ) )) //以写方式打开管道 &#123; perror(&quot;fopen error!\\r\\n&quot;); exit(1); &#125; write( fd, buf, strlen(buf) + 1 ); //向 fifo 写数据 close(fd); exit(0);&#125; read.c 123456789101112131415161718192021222324252627282930// 有名管道的 读端 代码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#define FIFO_NAME &quot;myfifo&quot;#define BUF_SIZE 1024int main( void )&#123; int fd; char buf[BUF_SIZE]; umask(0); fd = open( FIFO_NAME, O_RDONLY); int ret = read(fd, buf, BUF_SIZE ); if ( -1 == ret ) &#123; perror(&quot;read error!\\r\\n&quot;); exit(ret); &#125; printf(&quot;read %s from %s&quot;,buf,FIFO_NAME ); close(fd); exit(0);&#125; 运行效果： 无名管道pipe————-基于文件描述符相关说明：ls—-ls命令其实也是一个进程，会把当前目录中的文件都列出来，但是它不会直接输出，而是把本来要输出到屏幕上的数据通过管道输出到 grep 这个进程中，作为grep进程的输入，然后这个进程对输入的信息进行筛选，把存在于 string的信息的字符串以行为单位打印在屏幕上；特点：①只能用于具有亲缘关系的进程之间的通信， 即父子进程或兄弟进程之间②单工通信模式，具有 固定的读端 和 写端③管道可以看成一种特殊文件，读写可以用 read() 和 write() ,但它不属于任一文件系统，只存在于内存中 1、创建–pipe函数 12#include &lt;unistd.h&gt;int pipe( int fd[2] ); //返回：成功 0 错误 -1 fd 参数返回两个文件描述符， fd[0] 指向管道读端， fd[1] 指向管道写端—0-1 读 写fd[1] 的输出是 fd[0] 的输入——–写端 输出 给读端的输入 管道如何实现进程间的通信？[1]父进程 创建管道，得到两个文件描述符指向管道的两端[2]父进程 fork 出子进程， 子进程也有两个文件描述符 指向同管道[3]父进程关闭 fd[0]读，子进程关闭 fd[1]写，即父进程关闭管道 读端，子进程关闭管道 写端，因为管道只支持单向通信，管道由—环形队列实现流程： 注意：①只有在管道的读端存在时，向管道写入数据才有意义，否则写入会收到内核传来的 SIGPIPE信号（Broken Pipe 管道破裂）②向管道写入数据时，Linux不保证写入 的原子性，管道缓冲区只要有空间，写进程就会试图向管道写入数据，如果管道缓冲区已满， 写操作一直阻塞③父子进程在 运行时，它们的执行先后次序不能保证，为了保证 父子进程已经关闭了 相应的文件描述符， 可在两个进程中调用 sleep() 函数，也可以用 进程的同步互斥机制 demo：pipe.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define MAX_DATA_LEN 256 //定义最大数据长度#define DELAY_TIME 1 //延时时间int main()&#123; pid_t pid; //进程 id int pipe_fd[2]; //定义无名管道的文件描述符 char buf[MAX_DATA_LEN]; const char data[] = &quot;Pipe Test Program\\r\\n&quot;; int real_read, real_write; memset(buf, &#x27;\\0&#x27;,sizeof(buf) ); // create pipe if ( pipe( pipe_fd) &lt; 0 ) //success:0 error: -1 &#123; perror(&quot;create pipe error!\\r\\n&quot;); exit(-1); &#125; // fork 子进程 if (0== ( pid = fork())) //fork返回值： 0子进程 &gt;0 父进程 -1出错 &#123; // child process // 子进程关闭 写描述符，并通过sleep(1) 等待 父进程也关闭相应的描述符 close(pipe_fd[1]); sleep(DELAY_TIME ); // 子进程读取管道内容， if ( (real_read = read(pipe_fd[0], buf, MAX_DATA_LEN ) ) &gt;0 ) &#123; printf(&quot;%d bytes read from the pipe is &#x27;%s&#x27; \\r\\n &quot;, real_read, buf); &#125; close(pipe_fd[0] ); //关闭子进程 读 描述符 exit(0); &#125; else if ( pid &gt; 0 ) &#123; // 父进程 关闭读取 描述符 close( pipe_fd[0] ); if ( -1 != (real_write = write( pipe_fd[1], data, strlen(data) +1 )) ) &#123; printf(&quot;parent write %s to pipe, %d bytes\\r\\n&quot;,data, real_write ); &#125; close( pipe_fd[1] ); waitpid(pid, NULL, 0 ); //收集子进程退出信息 exit(0); &#125;&#125; 实现：","categories":[],"tags":[{"name":"有名管道","slug":"有名管道","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93/"}]},{"title":"生产者消费者demo-有名管道+信号量","slug":"生产者消费者demo-有名管道-信号量","date":"2020-08-10T00:57:06.000Z","updated":"2020-08-12T11:03:22.706Z","comments":true,"path":"2020/08/10/生产者消费者demo-有名管道-信号量/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/10/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85demo-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93-%E4%BF%A1%E5%8F%B7%E9%87%8F/","excerpt":"","text":"生产者-消费者 Demo相关描述：有一个有限缓冲区，（用有名管道实现 FIFO 式缓冲区）有两个线程，生产者和消费者，它们分别不停的把产品放入缓冲区 和 从缓冲区中拿走产品一个生产者在 缓冲区 满的时候必须等待消费者缓冲区 空的时候也必须等待因为缓冲区时是 临界资源， 所以生产者消费者必须互斥执行临界资源： // 一次仅允许一个进程使用的 共享资源&ensp; &ensp;&ensp;//各进程采取互斥的方式，实现共享的资源称作 临界资源&ensp; &ensp;&ensp;//消息队列、变量、数组、缓冲区—– 生产者—&gt; | 缓冲区资源 | –&gt; 消费者用有名管道来模拟 有限缓冲区有名管道：有名管道是一个能在互不相关进程之间传送数据的特殊文件，一个或多个进程向内写入数据，在另一端由一个进程负责读出，有名管道在文件系统中可见， ls， 又称为 FIFO ，先入先出–&amp;&amp;&amp;wht？ 如何建立有名管道？shell 交互创建有名管道 mknod // mkfifo 命令在有些系统中， mkond 产生的文件可能在 /etc 目录下程序中建立有名管道： 123456umask(0); //明确设置 umask，因为不知道谁会读写管道if ( mknod /*mkfifo*/ (&quot;test_fifo&quot;, S_IRUSR | S_IWUSR | S_IRUSR | S_IWGRP))&#123; perror(&quot;mkfifo&quot;); exit(0);&#125; 有名管道使用：用 read() 和 write() 进行操作如果用 读写方式 O_RDWR 方式打开， 则不会引起阻塞 使用 3 个信号量– 其中 avail 和 full 分别用来解决生产者和消费者线程间的同步问题avail 标识缓冲区中的空单元数， 初始值是 Nfull 标识缓冲区中的非空单元数，初始值是 0mutex 是互斥信号量， 初始值是 1—也可以用互斥锁实现 流程： 开始–&gt;建立有名管道–&gt;打开有名管道–&gt;初始化 3 个信号量–&gt;创建生产者、消费者线程 [1]生产者线程：p操作 avail(白嫖操作)—-&gt;p操作 mutex—–&gt;读管道—-&gt;V操作 full—-&gt;V操作 mutex—&gt;结束 [2]消费者线程：p操作 full –&gt; p操作 mutex–&gt; 写管道—&gt; V操作 avail—-&gt;v—mutex—&gt;结束 缓冲区3个单元，每个单元10字节，生成和消费过程随机(0-5s的随机时间间隔，而且生产者的速度差不多是消费者的 2 倍，) src： producer_customer.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;pthread.h&gt;// 相关头文件包含#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt; //#include &lt;semaphore.h&gt; //#include &lt;sys/ipc.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;// 警告不兼容 memset， 要包含头文件 string.h#include &lt;string.h&gt;#define MYFIFO &quot;myfifo&quot; //缓冲区有名管道的名字#define BUFFER_SIZE 3 //缓冲区的单元数#define UNIT_SIZE 10 //每个单元的大小#define RUN_TIME 30 //运行时间#define DELAY_TIME 5.0 //周期的最大值int fd; //全局定义文件描述符//pthread_mutex_t mutex;sem_t sem_mutex; //这里不是互斥锁，而是 信号量 sem_tsem_t avail, full;time_t end_time; //结束时间// 生产者线程处理函数void * producer( void * arg)&#123; int real_write; int delay_time = 0; // time_t time = time( NULL ); 获取系统时间，单位为s while( time(NULL) &lt; end_time ) //当前系统时间小于预定的结束时间 &#123; // 给延时时间赋随机值 // rand() 产生一个 0--0x7fff 即 0--32767 之间的随机数 // stdlib.h 中有 #define RAND_MAX 0X7fff // rand() / (RAND_MAX + 1.0 ) 就等于一个 0-1 之间的小数 // 分析： rand()最大 32767 最小 0 除以32767 就是 0-1 之间小数 // 不能等于1 再乘以 10就是 0-10 不等于 10，最后在加1 就是 // 0-10可以取到10了 // 另外一种方法生成 一定范围内的随机数 // int a = rand() % 10; 0-9 10会被整除，取不到 // 规定上下限 int a = rand() % 51 + 13; 13-63 // 因为 %51 最大取50 + 13 保证最大 63 delay_time = (int)( rand() * DELAY_TIME / ( RAND_MAX) /2.0 ) +1; sleep( delay_time ); printf(&quot;Producer:delay=%d\\r\\n&quot;,delay_time); // p 操作，白嫖先用， 信号量-1 sem_wait sem_wait( &amp;avail ); // avail 缓冲区的空单元 初始N 初始5, -1=4 sem_wait( &amp;sem_mutex ); //int * semvalue = NULL; int numsem; sem_getvalue( &amp;avail, &amp;numsem); printf(&quot;avail=%d\\r\\n&quot;, numsem ); // 把 sem 指向的信号量 当前值 放置在 semvalue 指向的整数上 成功返回 0, // error: -1 //sem_getvalue( &amp;avail, semvalue ); //printf(&quot;avail=%d\\r\\n&quot;, *semvalue ); //得到sem 的值要用 sem_getvalue /*生产者写入数据 */ if ( -1 == ( real_write = write(fd,&quot;hello you&quot;, UNIT_SIZE ) ) ) &#123; if ( errno == EAGAIN ) &#123; printf(&quot;The fifo has not been read yet,please try later\\r\\n&quot;); &#125; &#125; else //写入成功 &#123; printf(&quot;write %d to the fifo\\r\\n&quot;,real_write ); &#125; // V 操作释放 mutex-操作权 和 // full----full是fifo缓冲区的非空单元数，初始为 0，V操作 +1 // 当 full == size 的时候 就没有非空了 ，无法写 sem_post sem_post( &amp;full ); //full+1------- 0 +1 =1 sem_post( &amp;sem_mutex ); //sem_mutex 初始值1， 0 + 1 =1 &#125; pthread_exit( NULL );&#125;void * customer( void * arg)&#123; // 定义 buff 用于保存读出的数据 unsigned char read_buffer[ UNIT_SIZE ]; int real_read; //实际读出的字节数 int delay_time; while ( time(NULL ) &lt; end_time ) &#123; delay_time = (int)( rand() * DELAY_TIME / ( ( RAND_MAX)) / 2.0) + 1 ; sleep( delay_time ); int numsem; sem_getvalue(&amp;sem_mutex, &amp;numsem ); printf(&quot;Custom:sem_mutex=%d\\r\\n&quot;,numsem ); // p 操作 full 和 mutex 信号量 sem_wait( &amp;full ); //将 代表 非空单元数， -1, 没有可读的就阻塞，用于保证生产者先生产 sem_wait( &amp;sem_mutex ); // sem_mutex -1 = 0 //sem_getvalue(&amp;sem_mutex, &amp;numsem ); //printf(&quot;Custom:sem_mutex=%d\\r\\n&quot;,numsem ); // memset memset( read_buffer, &#x27;0&#x27;,UNIT_SIZE ); printf(&quot;Customer:delay=%d\\r\\n&quot;,delay_time); if ( -1 == (real_read = read(fd, read_buffer, UNIT_SIZE ))) &#123; if (errno == EAGAIN ) &#123; printf(&quot;No data yet\\r\\n&quot;); &#125; &#125; printf(&quot;read %s from fifo\\r\\n&quot;,read_buffer); // V 操作信号量，释放资源 mutex avail sem_post( &amp;avail ); //读取完让 avail + 1，可写的多一个 sem_post( &amp;sem_mutex ); &#125; pthread_exit(NULL); &#125; main.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;producer_customer.h&quot;int main()&#123; // 定义生产者和消费者的线程描述符 pthread_t producer_id, customer_id; int ret; // 先埋下种子 srand(time(NULL) ); end_time = time( NULL ) + RUN_TIME ; //定义结束时间 // 创建有名管道 fifo if ( ( mkfifo( MYFIFO, O_CREAT | O_EXCL) &lt; 0 ) &amp;&amp; ( errno != EEXIST )/* or mknod*/ ) &#123; printf(&quot;create fifo error!\\r\\n&quot;); return errno; //返回错误码 &#125; // open fifo fd = open( MYFIFO, O_RDWR); //可读可写 O_RDWR if ( -1 == fd ) &#123; perror(&quot;open fifo error\\r\\n&quot;); return fd; &#125; // 初始化 init 信号量为 1 ret = sem_init(&amp;sem_mutex, 0, 1); //0代表只用于线程间， 1是mutex的初始化值 // 初始化 avail 的信号量为 N 成功 0 失败 -1 ret += sem_init( &amp;avail, 0, BUFFER_SIZE ); // 初始化 full 信号量 为 0 ret += sem_init( &amp;full, 0, 0); if ( 0 != ret) &#123; perror(&quot;some sem init error!\\r\\n&quot;); return ret; &#125; // 创建两个线程 ret = pthread_create( &amp;producer_id, NULL , producer, NULL); //有参的话传入 void * if ( 0 != ret ) &#123; perror(&quot;create pthread_producer error!\\r\\n&quot;); return ret; &#125; ret = pthread_create( &amp;customer_id, NULL, customer, NULL); if ( 0 != ret ) &#123; perror(&quot;create pthread_customer error!\\r\\n&quot;); return ret; &#125; // 阻塞等待线程结束 pthread_join pthread_join( producer_id, NULL ); //void ** result pthread_join( customer_id, NULL ); close(fd ); //关闭打开的文件描述符 unlink( MYFIFO ); //关闭管道连接 return 0;&#125; 运行结果:","categories":[{"name":"生产者消费者demo","slug":"生产者消费者demo","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85demo/"}],"tags":[{"name":"有名管道，信号量","slug":"有名管道，信号量","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%87%8F/"}]},{"title":"线程-demo问题","slug":"线程-demo问题","date":"2020-08-09T09:29:28.000Z","updated":"2020-08-10T11:23:08.790Z","comments":true,"path":"2020/08/09/线程-demo问题/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/09/%E7%BA%BF%E7%A8%8B-demo%E9%97%AE%E9%A2%98/","excerpt":"","text":"src：thread.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#define PTHREAD_NUM 2#define NUM 0#define PARAM 0pthread_mutex_t mutex;void * pthread_func_1( void * arg);void * pthread_func_1( void * arg)&#123; //int count = *((int *)arg); int count = (int )arg; printf(&quot;count=%d\\r\\n&quot;,count); int param = PARAM; int res = 0; // arg 用来标识是哪个线程 if( 0 == count ) &#123; while(1) &#123; // lock if ( 0 != (res = pthread_mutex_lock(&amp;mutex) ) ) &#123; perror(&quot;lock error!\\r\\n&quot;); pthread_exit(NULL); &#125; printf(&quot;thread %d lock\\r\\n&quot;,count ); // 线程 1 param = 0; printf(&quot;thread 1: param=%d\\r\\n&quot;,param); //unlock if ( 0 != ( res = pthread_mutex_unlock(&amp;mutex) )) &#123; perror(&quot;unlock error!\\r\\n&quot;); pthread_exit(NULL); &#125; printf(&quot;thread %d unlock\\r\\n&quot;,count); sleep(2); &#125; &#125; else if( 1 == count ) &#123; while(1) &#123; // lock if ( 0 != (res = pthread_mutex_lock(&amp;mutex) ) ) &#123; perror(&quot;lock error!\\r\\n&quot;); pthread_exit(NULL); &#125; printf(&quot;thread %d lock\\r\\n&quot;,count ); // 线程 1 param = 1; printf(&quot;thread 1: param=%d\\r\\n&quot;,param); //unlock if ( 0 != ( res = pthread_mutex_unlock(&amp;mutex) )) &#123; perror(&quot;unlock error!\\r\\n&quot;); pthread_exit(NULL); &#125; printf(&quot;thread %d unlock\\r\\n&quot;,count); sleep(2); &#125; &#125; return (void *)0;&#125; main.c 123456789101112131415161718192021222324252627282930#include &quot;thread.h&quot;int main( void )&#123; // 初始化 锁 pthread_mutex_init(&amp;mutex, NULL); pthread_t thread[PTHREAD_NUM]; // pthread_t 数组 保存生成的 pthread_t 线程描述符 // create thread int num=0,res=0; for (num=0;num&lt;PTHREAD_NUM;num++) &#123; res=pthread_create( &amp;thread[num],NULL,pthread_func_1,(void *)num ); if ( 0 != res ) &#123; perror(&quot;create pthread error\\r\\n&quot;); exit(res); &#125; printf(&quot;thread %d create success!\\r\\n&quot;,num); &#125; printf(&quot;pthread create success,wait for:\\r\\n&quot;); // destroy sleep(10); pthread_mutex_destroy(&amp;mutex); return 0;&#125; 运行效果：","categories":[{"name":"进程线程","slug":"进程线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"线程bug","slug":"线程bug","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8Bbug/"}]},{"title":"线程-信号量","slug":"线程-信号量","date":"2020-08-08T16:34:24.000Z","updated":"2020-08-12T11:03:22.059Z","comments":true,"path":"2020/08/09/线程-信号量/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/09/%E7%BA%BF%E7%A8%8B-%E4%BF%A1%E5%8F%B7%E9%87%8F/","excerpt":"","text":"信号量就是： （主要用于共享数据的同步访问）操作系统中用到的 PV 原子操作，广泛应用于进程和线程间的同步和互斥本质：是一个 非负 的整数计数器，被用来控制对公共资源的访问PV 操作主要用于 同步 和 互斥 两种应用场景 linux 实现 POSIX 的无名信号量用于线程间的同步互斥 sem接口函数操作的参数都是信号量指针 sem_t *[1]初始化信号量#include &lt;semaphore.h&gt; 12345int sem_init( sem_t * sem, int pshared, unsigned int value);sem:信号量对象 pshared：决定信号量是否在线程间共享，目前未实现，默认0，标识只能进程内的线程间 共享value：信号量初始化值return: success:0 error:-1 [2]sem_wait() 和 sem_trywait() 相当于 p 操作———-P 代表白嫖p， 用内容在信号量 &gt; 0 时能将信号量值 -1，区别：信号量为 0 时， sem_wait 会阻塞， sem_trywait 立即返回 1int sem_wait( sem_t * sem ); //获取信号量，不成功则----阻塞 [3]sem_post() 相当于 V 操作——-V 释放 将信号量的值 +1， 同时唤醒等待的线程 1int sem_post( sem_t * sem ); //释放信号量 [4]sem_getvalue() 获得信号量的值 [5]sem_destroy() 删除信号量 1、 互斥几个进程（或线程）往往只设置一个信号量 sem。 2、同步信号量用于同步操作时， 往往会设置多个信号量，并安排不同的初始值来实现 它们 之间的顺序执行","categories":[{"name":"进程线程","slug":"进程线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"信号量","slug":"信号量","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"}]},{"title":"线程-互斥锁","slug":"线程间同步互斥","date":"2020-08-08T02:38:51.000Z","updated":"2020-08-12T10:17:03.895Z","comments":true,"path":"2020/08/08/线程间同步互斥/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/08/%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5/","excerpt":"","text":"由于线程共享进程的资源和地址空间，因此在对资源操作时，必须考虑到线程间资源的访问和互斥问题 1、互斥锁线程控制&ensp; &ensp;&ensp;&ensp;&ensp;互斥锁通过简单的方式保证对共享资源的原子操作&ensp; &ensp;&ensp;&ensp;&ensp;原子操作是不可分割的，在执行完毕之前不会被任何其它任务或事件中断 互斥锁操作： 上锁 和 解锁同一时刻只能有一个线程持有某个互斥锁，拥有互斥锁的线程能够对共享资源进行操作，若线程对一个已经被上锁的互斥锁加锁，该线程就会睡眠，直到其他线程释放掉互斥锁为止。互斥锁机制实现函数：#include &lt;pthread.h&gt;[1]互斥锁初始化： 123pthread_mutex_init( pthread_mutex_t * mutex, const pthread_mutexattr_t * mutexattr);mutex；互斥锁 mutexattr:互斥锁属性， NULL 标识缺省参数return: success:0 error:错误码 [2]互斥锁上锁： 1pthread_mutex_lock( pthread_mutex_t * mutex ); //加锁，不成功则阻塞自己 [3]互斥锁判断上锁 1pthread_mutex_trylock( pthread_mutex_t * mutex); //加锁，若不成功则返回，立即返回！！ [4]互斥锁解锁 1pthread_mutex_unlock( pthread_mutex_t * mutex ); [5]消除/摧毁 互斥锁 1pthread_mutex_destroy( pthread_mutex_t * mutex ); 线程间互斥锁Demo：pthread_mutex.h 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define THREAD_NUM 3 //定义线程数#define REPEAT_TIMES 3 //定义线程的循环次数#define DELAY_TIME 6.0 //定义循环之间的最大时间间隔pthread_mutex_t mutex; //定义全局的线程互斥锁// 线程的功能函数void * thread_function( void * arg )&#123; int thread_num = (int)arg; //标识是哪一个线程 int delay_time = 0,count=0; //count计数 int res; // lock res = pthread_mutex_lock( &amp;mutex ); if( 0 != res ) //or ( res ) &#123; printf(&quot;Thread %d lock failed\\r\\n&quot;, thread_num); pthread_exit( NULL ); &#125; printf(&quot;Thread %d is start\\r\\n&quot;, thread_num); for(count=0;count&lt;REPEAT_TIMES; count++ ) &#123; delay_time = (int)( rand()*DELAY_TIME/(RAND_MAX)) +1; sleep( delay_time ); printf(&quot;Thread %d :job:%d,delay:%d&quot;,thread_num,count,delay_time); &#125; printf(&quot;Thread %d finish\\r\\n&quot;,thread_num); // unlock pthread_mutex_unlock( &amp;mutex); pthread_exit(NULL);&#125; main.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &quot;pthread_mutex.h&quot;int main(void )&#123; pthread_t thread[THREAD_NUM ]; //创建pthread_t 类型的数组标识线程 标识符 //解析：之所以用数组没有初始化直接传参是create函数会返回phread_t 类型，指针用于返回值 int no = 0,res; void * thread_res; srand(time(NULL)); // mutex_init pthread_mutex_init( &amp;mutex, NULL ); for ( no=0;no&lt;THREAD_NUM;no++) &#123; // create pthread res = pthread_create(&amp; thread[no], NULL, thread_function, (void *)no ); //最后是线程功能函数需要的参数 if ( 0 != res ) &#123; printf(&quot;Create thread %d failed\\r\\n&quot;,no ); exit(res); &#125; &#125; printf(&quot;Create all success,wait for finish\\r\\n&quot;); //阻塞式等待结束 for(no=0;no&lt;THREAD_NUM;no++) &#123; res = pthread_join( thread[no], &amp;thread_res ); //param2：接收被等候待线程结束返回值 是 void ** if ( 0 == res ) //or (!res) &#123; printf(&quot;Thread %d joined&quot;, no); &#125; else &#123; printf(&quot;Thread %d joined failed\\r\\n&quot;,no); &#125; &#125; pthread_mutex_destroy( &amp;mutex); return 0;&#125; 执行结果","categories":[{"name":"进程线程","slug":"进程线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"线程通信","slug":"线程通信","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"}]},{"title":"进程-linux","slug":"进程-linux","date":"2020-08-07T07:47:39.000Z","updated":"2020-08-07T07:47:39.779Z","comments":true,"path":"2020/08/07/进程-linux/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/07/%E8%BF%9B%E7%A8%8B-linux/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"网络编程传输协议详解","slug":"网络编程传输协议详解","date":"2020-08-07T07:46:19.000Z","updated":"2020-08-07T07:46:19.075Z","comments":true,"path":"2020/08/07/网络编程传输协议详解/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"诺瓦2020提前批笔试","slug":"诺瓦2020提前批笔试","date":"2020-08-07T02:21:03.000Z","updated":"2020-08-09T09:47:13.111Z","comments":true,"path":"2020/08/07/诺瓦2020提前批笔试/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/07/%E8%AF%BA%E7%93%A62020%E6%8F%90%E5%89%8D%E6%89%B9%E7%AC%94%E8%AF%95/","excerpt":"","text":"flight.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#ifndef HEAD_H#define HEAD_H/* * description: * 航班和乘客，乘客中用 GREEN、YELLOW、RED 标识身体情况， 规则: * 一列航班中 RED==0 没有问题 * RED &gt; 10% 紧急停机检查 * 0 &lt; RED &lt; 10% * 有风险，抵达目的地后进行检查 * 代码实现 **/// &lt;封装 乘客struct&gt; select 链表typedef struct passenger&#123; char * name; char * id_card; struct passenger * pNext; int flight_id; int healthcode; // 乘客的健康等级&#125;passenger_t;// &lt;封装 flight struct&gt;typedef struct flight&#123; const char * orig_city;//初始地 const char * dest_city; int flight_id; struct flight * pNext; passenger_t * pHead_passenger; //飞机包含乘客链表 int Goodlevel; //评估飞机的安全等级 int passengerNum; //保存航班的乘客总人数 int redNum; // int yellowNum;&#125;flight_t;typedef enum&#123; EN_GREEN, EN_YELLOW, EN_RED&#125;en_health_code;/* * function:create a flightHead * return:pHead_flight */flight_t * createFlight( void );/* * function:create a passengerHead * return:pHead_passenger * */passenger_t * createPassenger( void );//添加航班信息int addFlight(flight_t * pHead,int flight_id, const char * orig_city, const char * dest_city );//添加乘客信息int addPassenger( flight_t * pHead, int flight_id, char * name, char * id_card, int healthcode );int showPassenger( flight_t * pHead,int flight_id );void showFlight( flight_t * pHead);// function:计算某航班的风险值并返回int getRisk( flight_t * pHead, int flight_id );#endif flight.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include &quot;flight.h&quot;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;flight_t * createFlight( void )&#123; flight_t * pHead_flight = (flight_t * )malloc( sizeof( flight_t )); if ( NULL == pHead_flight ) &#123; return (flight_t *)0; &#125; memset( pHead_flight , &#x27;\\0&#x27; , sizeof( flight_t ) ); pHead_flight-&gt;flight_id = 0; pHead_flight-&gt;pNext = NULL; printf(&quot;create flight success\\r\\n&quot;); return pHead_flight;&#125;passenger_t * createPassenger( void )&#123; passenger_t * pHead_passenger = (passenger_t * )malloc( sizeof( passenger_t)); if ( NULL == pHead_passenger ) &#123; return ( passenger_t * )0; &#125; memset( pHead_passenger , &#x27;\\0&#x27; , sizeof( passenger_t ) ); printf(&quot;create passenger success\\r\\n&quot;); return pHead_passenger;&#125;int addFlight( flight_t * pHead, int flight_id, const char * orig_city, const char * dest_city )&#123; if ( NULL==pHead || flight_id &lt; 0 || NULL == orig_city || NULL == dest_city ) &#123; perror(&quot;param error!\\r\\n&quot;); return -1; &#125; flight_t * temp = (flight_t * )malloc( sizeof(flight_t )); memset(temp, &#x27;\\0&#x27;, sizeof(flight_t ) ); flight_t * pNew = (flight_t * )malloc( sizeof(flight_t )); memset( pNew , &#x27;\\0&#x27;, sizeof(flight_t ) ); //不能对空指针进行赋值， 要新 malloc pNew pNew-&gt;flight_id = flight_id; pNew-&gt;orig_city = orig_city; pNew-&gt;dest_city = dest_city; pNew-&gt;pHead_passenger =(passenger_t *)malloc( sizeof( passenger_t )); temp = pHead; while( temp-&gt;flight_id != flight_id &amp;&amp; temp-&gt;pNext != NULL ) //对，应该判断前一个，然后赋值好赋值 &#123; temp =temp-&gt;pNext; &#125; if (temp != NULL &amp;&amp; temp-&gt;flight_id == flight_id ) &#123; perror(&quot;flight already exist!, add error\\r\\n&quot;); return -1; &#125; temp-&gt;pNext= pNew; printf(&quot;add success\\r\\n&quot;); return 0;&#125;void showFlight( flight_t * pHead)&#123; if(NULL ==pHead) &#123; perror(&quot;param error!\\r\\n&quot;); return; &#125; flight_t* temp = pHead; while( temp != NULL ) &#123; // flight_id=0是头节点，可不打印 if( 0 == temp-&gt;flight_id ) &#123; temp = temp-&gt;pNext; &#125; printf(&quot;flight_id--%d 起始地点--%s, 目的地点--%s \\r\\n&quot;, temp-&gt;flight_id, temp-&gt;orig_city, temp-&gt;dest_city ); temp = temp-&gt;pNext; &#125; printf(&quot;show ok\\r\\n&quot;); return;&#125;int addPassenger( flight_t * pHead ,int flight_id, char * name, char * id_card, int healthcode ) &#123; if ( NULL == pHead || flight_id &lt;0 || NULL == name || NULL == id_card ) &#123; perror(&quot; param error\\r\\n&quot;); return -1; &#125; flight_t * ptmp = pHead; while ( ptmp-&gt;flight_id != flight_id ) &#123; ptmp = ptmp-&gt;pNext; if ( NULL == ptmp) &#123; perror(&quot; flight_id error!\\r\\n&quot;); return -2; &#125; &#125; passenger_t * pNew = ( passenger_t *)malloc( sizeof(passenger_t )); pNew-&gt;flight_id=flight_id; //0 green 1 yellow 2 red pNew-&gt;healthcode=healthcode; pNew-&gt;id_card = id_card; pNew-&gt;name = name; ptmp-&gt;passengerNum += 1; if( 2 == healthcode ) &#123; ptmp-&gt;redNum += 1; &#125; else if( 1 == healthcode ) &#123; ptmp-&gt;yellowNum += 1; &#125; passenger_t * pq = ( passenger_t *)malloc( sizeof(passenger_t )); pq = ptmp-&gt;pHead_passenger; while( pq-&gt;pNext != NULL) &#123; pq = pq-&gt;pNext; &#125; pq-&gt;pNext = pNew; return 0;&#125;int showPassenger( flight_t * pHead, int flight_id )&#123; if ( NULL == pHead || flight_id &lt; 0) &#123; perror(&quot; param error\\r\\n&quot;); return -1; &#125; flight_t * temp = pHead; // 用temp-&gt;pNext 做判断最后好赋值 while( temp-&gt;pNext != NULL &amp;&amp; temp-&gt;flight_id != flight_id ) &#123; temp = temp-&gt;pNext; &#125; if (temp-&gt;flight_id != flight_id &amp;&amp; temp-&gt;pNext == NULL) &#123; perror(&quot; flight_id error!\\r\\n&quot;); return -2; &#125; if (temp-&gt;flight_id == flight_id ) &#123; //passenger_t * pp = temp-&gt;pHead_passenger; 因为第一个是头节点，不打印 passenger_t * pp = temp-&gt;pHead_passenger-&gt;pNext; while ( pp != NULL) //遍历打印是 pp != NULL &#123; printf(&quot;passenger info:// name:%s, card_id:%s, healthcode:%d, flight_id:%d, origCity:%s, destCity:%s \\r\\n&quot;, pp-&gt;name,pp-&gt;id_card,pp-&gt;healthcode,pp-&gt;flight_id, temp-&gt;orig_city,temp-&gt;dest_city); pp=pp-&gt;pNext; &#125; &#125; return 0;&#125; int getRisk( flight_t * pHead, int flight_id )&#123; if ( NULL == pHead || flight_id &lt; 0 ) &#123; perror(&quot; param error!\\r\\n&quot;); return -1; &#125; flight_t * ptemp = pHead; while ( ptemp-&gt;flight_id != flight_id &amp;&amp; ptemp-&gt;pNext != NULL ) &#123; ptemp = ptemp-&gt;pNext; &#125; if ( ptemp-&gt;pNext == NULL &amp;&amp; ptemp-&gt;flight_id != flight_id) &#123; return -2; &#125; float redRisk =(float)ptemp-&gt;redNum / (float)ptemp-&gt;passengerNum; printf(&quot;passengerNum=%d, redNum=%d, yellowNum=%d\\r\\n&quot;,ptemp-&gt;passengerNum,ptemp-&gt;redNum, ptemp-&gt;yellowNum); printf(&quot;redRisk=%f\\r\\n&quot;, redRisk); if( 0 == redRisk) &#123; ptemp-&gt;Goodlevel = 0; printf(&quot;plane safe, take off\\r\\n&quot;); &#125; else if( redRisk &gt;= 0.1 ) &#123; ptemp-&gt;Goodlevel = 2; printf(&quot;dangerous!!!!stop \\r\\n&quot;); &#125; else if( redRisk &gt; 0 &amp;&amp; redRisk &lt; 0.1 ) &#123; ptemp-&gt;Goodlevel = 1; printf( &quot;just ok,but still need to be examine\\r\\n&quot; ); &#125; return 0;&#125; main.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &quot;flight.h&quot;int main(void)&#123; flight_t * pHead_flight = createFlight(); passenger_t * pHead_passenger = createPassenger(); addFlight(pHead_flight, 1, &quot;zhengzhou&quot;,&quot;xian&quot;); addFlight(pHead_flight, 2, &quot;beijing&quot;,&quot;xian&quot;); //addFlight(pHead_flight, 2, &quot;xinjiang&quot;,&quot;xian&quot;); addPassenger(pHead_flight,1,&quot;Jim&quot;, &quot;12345&quot;,0); addPassenger(pHead_flight,1,&quot;SU&quot;, &quot;sadw&quot;, 2); addPassenger(pHead_flight,1,&quot;zhang&quot;,&quot;334&quot;, 1); addPassenger(pHead_flight,1,&quot;li&quot;, &quot;888&quot;, 1); addPassenger(pHead_flight,1,&quot;q&quot;, &quot;812&quot;, 1); addPassenger(pHead_flight,1,&quot;s&quot;, &quot;833&quot;, 1); addPassenger(pHead_flight,1,&quot;qwd&quot;, &quot;124&quot;, 1); addPassenger(pHead_flight,1,&quot;trgh&quot;, &quot;oa9&quot;, 1); addPassenger(pHead_flight,1,&quot;dwew&quot;, &quot;wevc&quot;,1); addPassenger(pHead_flight,1,&quot;uh&quot;, &quot;okn&quot;, 1); addPassenger(pHead_flight,2,&quot;sfd&quot;, &quot;plm&quot;, 1); addPassenger(pHead_flight,2,&quot;yth&quot;, &quot;adv&quot;, 1); addPassenger(pHead_flight,2,&quot;sf&quot;, &quot;okq&quot;, 1); addPassenger(pHead_flight,2,&quot;alib&quot;, &quot;13df&quot;,1); addPassenger(pHead_flight,2,&quot;niuniu&quot;,&quot;asf3&quot;,1); addPassenger(pHead_flight,2,&quot;gui&quot;, &quot;qa1&quot;,1); addPassenger(pHead_flight,2,&quot;ww&quot;, &quot;qa2&quot;,1); addPassenger(pHead_flight,2,&quot;gg&quot;, &quot;qa3&quot;,1); addPassenger(pHead_flight,2,&quot;ym&quot;, &quot;qa4&quot;,1); addPassenger(pHead_flight,2,&quot;shui&quot;, &quot;qa5&quot;,1); addPassenger(pHead_flight,2,&quot;alp&quot;, &quot;ws5&quot;,1); addPassenger(pHead_flight,2,&quot;hub&quot;, &quot;sf6&quot;,0); getRisk( pHead_flight, 1); getRisk( pHead_flight, 2); showFlight( pHead_flight ); showPassenger(pHead_flight, 1); return 0;&#125; 运行效果参考：","categories":[],"tags":[{"name":"链表","slug":"链表","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"线程-linux","slug":"线程-linux","date":"2020-08-05T07:47:14.000Z","updated":"2020-08-12T11:03:23.473Z","comments":true,"path":"2020/08/05/线程-linux/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/05/%E7%BA%BF%E7%A8%8B-linux/","excerpt":"","text":"线程–轻量级进程 // 内核调度的最小单元为了进一步减少处理器的空转时间，支持多处理器，减少上下文切换开销 上下文切换：指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换，上下文切换过程中的信息被保存在进程控制块（PCB-Process Control Block）中 过程： ` [1]先挂起一个进程，把这个进程在cpu中的状态（上下文信息）存储在内存的 PCB 中 [2]在PCB中检索下一个进程的上下文并将其在CPU的寄存器中恢复 [3]跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行）并恢复该进程` linux中的线程依赖于 pthread 线程库 1、创建线程： pthread_create( pthread_t * thread, pthread_attr_t *attr,void *( *start_routine)(void *), void * arg); thread: 线程标识符 attr: 线程属性设置， NULL 表示缺省属性 start_routine: 线程执行函数，参数和返回值都是 void * arg: 传递给 线程执行函数用的参数 return: success:0 error:错误码 2、退出线程: pthread_exit( void * retval ); retval: 线程结束时的返回值， 可以通过 pthread_join() 来接收//但是使用中不能用 exit 退出线程，因为一般一个进程中包含多个线程，exit的作用是使当前进程终止，进程中所以线程都会over—所以退出线程用 pthread_exit() 来替代 线程主动结束：可以调用 pthread_exit() 一个线程终止另外一个线程： 调用 pthread_cancel() 实现// 在被取消的线程内部要 先调用 pthread_setcancel() 和 pthread_setcanceltype() 设置相应的取消状态 3、pthread_join() 以阻塞的方式等待 thread 指定的线程结束，函数返回时，被等待线程的资源被回收，如果线程已经结束，该函数会立即返回 resutn: success:0 error:错误号 函数原型： pthread_join( pthread_t pthread, void ** thread_result ); thread:被等待线程的标识符 thread_result: 用户定义的指针，用来接收被等待线程结束时的返回值（如果返回不为NULL） **为什么是二级指针：**原因：一级指针只能用来改变指向内存的值，传递的就是指针p内存的地址,所以修改它就是修改了它自己的指向; 4、pthread_cancel( pthread_t thread ) thread: 要取消的线程的 标识符 return: success:0 error:错误码 线程函数使用 Demo // 编译的时候需要链接 pthread thread.h #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #define THREAD_NUM 3 // 线程数 #define REPEAT_TIMES 5 //每个线程中的循环次数限制 #define DELAY_TIME 6.0 //循环之间的最大时间间隔 线程处理函数 void * thread_function( void * arg){ int thread_num = (int )arg; //线程总数 int delay_time = 0; //延时 int count = 0; //计调用次数 printf(&quot;thread %d start!\\r\\n&quot;,thread_num); for (count=0;count&lt;REPEAT_TIMES; count++ ) &#123; delay_time = (int)( rand() * DELAY_TIME / (RAND_MAX) ) +1 ; sleep( delay_time ); //随机等待1--6 s, 模拟任务完成的时间随机 printf(&quot;Thread %d :job %d delay = %d\\r\\n&quot;, thread_num,count, delay_time); &#125; printf(&quot;Thread %d is finished\\r\\n&quot;, thread_num); pthread_exit(NULL); //任务完成自行结束 } main.c #include “thread.h” int main( void ){ pthread_t thread[THREAD_NUM]; //定义存放 thread 号的类型数组 int no = 0,res; void * thread_ret; srand( time( NULL )); //埋下时间种子 for( no=0; no&lt;THREAD_NUM; no++) &#123; res = pthread_create(&amp;thread[no], NULL, thread_function, (void*)no ); //创建的时候是 pthread_t * // no 标识是第几个线程 if ( res != 0 ) //create error &#123; printf(&quot;Create thread %d error\\r\\n&quot;, no); exit(res); // 结束进程， &lt;stdlib.h&gt; 参数不为0都异常 &#125; &#125; printf(&quot;Create threads success!\\r\\n&quot;); for( no=0;no&lt;THREAD_NUM;no++) &#123; // pthread_join: pthread_t thread res = pthread_join( thread[no], &amp;thread_ret); //阻塞式等待线程退出 //param_2 被等待线程结束的返回值, void ** thread_result if ( 0 == res ) //success:0 error:错误号 &#123; printf(&quot;Thread %d joined\\r\\n&quot;,no); &#125; else &#123; printf(&quot;Thread %d joined failed\\r\\n&quot;, no); &#125; &#125; return 0; } 运行情况：","categories":[{"name":"多进程/线程","slug":"多进程-线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"进制间转换","slug":"进制间转换","date":"2020-08-04T11:08:07.000Z","updated":"2020-08-10T11:22:23.239Z","comments":true,"path":"2020/08/04/进制间转换/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/04/%E8%BF%9B%E5%88%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"&lt;10进制—&gt;2进制&gt; 1234567ex: 19---&gt; 19 / 2 = 9....1 9 / 2 = 4....1 4 / 2 = 2....0 2 / 2 = 1....0 1 / 2 = 0....1 反序取余数 10011 10进制中的 小数部分–&gt;2进制 1234ex: 0.75小数不断×2取整，直到没有小数为止，注意:不是所有的小数都可以转为 2 进制 0.75 * 2 = 1.5 取整 1 0.5 * 2 = 1 顺序取数得: 0.11 &lt;16进制—-&gt; 10进制 &gt; 123456716进制 是 16 进 1 0 1 2 3 4 5 6 7 8 9 A(10) B C D E F(15)ex: 2AF5 = 5* 16^0 + F*16^1 + A*16^2 + 2*16^3 = 5 + 15*16 + 10*256 + 2*4096 = 5 + 240 + 2560 + 8192 = 10997 &lt;10进制 —-&gt; 16进制&gt; 1234567余数定理分解ex： 48774877 / 16 = 304....13 304 / 16 = 19....0 19 / 16 = 1.....3 1 / 16 = 0.....1 结果 = 130D (注意顺序)","categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"stm32-port1","slug":"stm32-port1","date":"2020-08-04T04:37:50.000Z","updated":"2020-08-04T04:37:50.998Z","comments":true,"path":"2020/08/04/stm32-port1/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/04/stm32-port1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-08-02T19:39:29.453Z","updated":"2020-08-10T08:09:40.010Z","comments":true,"path":"2020/08/03/hello-world/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/03/hello-world/","excerpt":"","text":"欢迎来到 NiuNiu 的技术经验分享博客网站但凡流行的工具、技术，都是入门易，精通难，想有所成就，都需要不懈的努力和漫长的积累，愿诸君与我共勉！不缺拳打世界的勇气,亦有归去风雨无晴的洒脱，~-Z","categories":[],"tags":[]},{"title":"单向不循环链表","slug":"单向不循环链表","date":"2020-08-01T16:48:16.000Z","updated":"2020-08-12T11:03:20.621Z","comments":true,"path":"2020/08/02/单向不循环链表/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/02/%E5%8D%95%E5%90%91%E4%B8%8D%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/","excerpt":"","text":"链表： 动态的数据结构，分为数据域和指针域， 动态进行存储分配，实现数据增删 优点： ​ 1、存储空间动态分配，可以根据实际需要使用 ​ 2、不需要地址连续的存储空间 ​ 3、插入/删除操作只需通过修改指针实现，不必移动数据元素， 操作时间效率高 ，插入删除事件复杂度 O(1) 缺点： ​ 1、每个链节点需要设置指针域（ 存储密度小 ） ​ 2、是一种非随机存储结构，查找/定位等操作都需要顺序扫描链表实现，时间效率低 O(n) [TOC] Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258/* 头节点:数据域为空 头节点:数据域为空 malloc 申请 &lt;malloc.h&gt; memset 初始化 &lt;string.h&gt;*/typedef int datatype; typedef struct link&#123; datatype data; struct link * pNext;&#125;Link;// 枚举 中间用, 未赋值默认第一个为0enum opt&#123; ERR=-1, OK, TAIL=-1, HEAD,&#125;;// [1]创建链表---即生成头节点Link * createLink(void);Link * createLink(void)&#123; Link * pHead =NULL; pHead=(Link *)malloc(sizeof(Link)); if(NULL==pHead) &#123; return NULL; &#125; memset(pHead,&#x27;\\0&#x27;,sizeof(Link)); return pHead;&#125;// [2]插入节点---头插，尾插，中间插//根据位置给链表添加节点//参数：链表首地址，要添加的元素，和插入的位置//HEAD=0 TAIL=-1 其他中间//返回值 成功 OK 失败 ERRint InsertLink(Link * pHead, datatype item,int offset);int InsertLink(Link * pHead, datatype item,int offset)&#123; if(NULL==pHead) &#123; return ERR; &#125; int k=0; Link * pNew=NULL; Link * pTmp=pHead; //如果写pHead-&gt;pNext要判断是否为空所以为了方便写pHead pNew=(Link *)malloc(sizeof(Link)); if(NULL==pNew) &#123; return ERR; &#125; pNew-&gt;data=item; pNew-&gt;pNext=NULL; switch(offset) &#123;case HEAD: pNew-&gt;pNext=pHead-&gt;pNext; pHead-&gt;pNext=pNew; break;case TAIL: while(pTmp-&gt;pNext!=NULL) &#123; pTmp=pTmp-&gt;pNext; &#125; pTmp-&gt;pNext=pNew; break;default: while(k &lt; offset-1 &amp;&amp; pTmp != NULL) //pTmp!=NULL说明找到插入位置，如果pTmp==NULL,表示未找到要free(pNew)再返回报错 &#123; k++; pTmp=pTmp-&gt;pNext; &#125; if(pTmp==NULL) //先判断是否为空 &#123; free(pNew); return ERR; &#125; pNew-&gt;pNext=pTmp-&gt;pNext; pTmp-&gt;pNext=pNew; break; &#125;&#125;// [3]打印输出---遍历int show(Link * pHead);int show(Link * pHead)&#123; if(NULL==pHead) &#123; return ERR; &#125; Link * pTmp=pHead-&gt;pNext; while(pTmp!=NULL) &#123; printf(&quot; %d &quot;,pTmp-&gt;data); pTmp=pTmp-&gt;pNext; &#125; printf(&quot;\\n&quot;);&#125;// [4]删除节点----头删，尾删，中间删int DeleteLink(Link * pHead,int offset,datatype * pData);int DeleteLink(Link * pHead,int offset,datatype * pData)&#123; if(NULL==pHead||NULL==pData) &#123; return ERR; &#125; Link * pDel=NULL; Link * pPre=NULL; int k=0; switch(offset) &#123; case HEAD: pDel=pHead-&gt;pNext; if(pDel==NULL) //一定要判断 &#123; *pData=0; printf(&quot;链表为空！\\n&quot;); return ERR; &#125; pHead-&gt;pNext=pDel-&gt;pNext; //先将删除的数保存 *pData=pDel-&gt;data; free(pDel); pDel=NULL; break; case TAIL: pPre=pHead; pDel=pHead-&gt;pNext; if(pDel==NULL) //说明没有什么删除的，空链表是pHead-&gt;pNext为空 &#123; printf(&quot;链表为空!\\n&quot;); *pData=0; return ERR; while(pDel-&gt;pNext!=NULL) &#123; pPre=pDel; pDel=pDel-&gt;pNext; &#125; //保存删除的数据v *pData=pDel-&gt;data; free(pDel); pDel=NULL; //把pre变成尾节点 pPre-&gt;pNext=NULL; break; &#125; default: pPre=pHead; pDel=pHead-&gt;pNext; k=0; while(k&lt;offset-1&amp;&amp;pDel!=NULL) &#123; k++; pPre=pDel; //是pPre=pDel;; pDel=pDel-&gt;pNext; &#125; if(pDel==NULL) &#123; printf(&quot;链表为空!\\n&quot;); *pData=0; return ERR; &#125; *pData=pDel-&gt;data; pPre-&gt;pNext=pDel-&gt;pNext; free(pDel); pDel=NULL; break; &#125;&#125;// [5]销毁链表Link * Destroy(Link * pHead);Link * Destroy(Link * pHead)&#123; if(NULL==pHead) &#123; return NULL; &#125; Link * pDel=NULL; //while(pDel!=NULL) //while(1)是死循环 永远成立； while(1) &#123;//找到链表中的首节点 pDel=pHead-&gt;pNext; if(pDel==NULL) &#123; break; &#125; //保护好首节点后的所有节点 pHead-&gt;pNext=pDel-&gt;pNext; //释放首节点 free(pDel); pDel=NULL; &#125; //最后再释放头节点 free(pHead); pHead=NULL; printf(&quot;链表已删除\\n&quot;); return pHead; //一定要返回 pHead 否则会错误&#125;// [6]链表逆序---拓展int Negative(Link * pHead); //Negative sequence 逆序int Negative(Link * pHead) //Negative sequence 逆序&#123; if(NULL==pHead) &#123; return ERR; &#125; Link * pA=NULL; Link * pB=NULL; pA=pHead-&gt;pNext; //保护好头节点后的所有节点 //原链表变为空链表 pHead-&gt;pNext=NULL; //保护好首节点后的所有节点 while(1) &#123; pB=pA-&gt;pNext; //首节点插入到新链表 pA-&gt;pNext=pHead-&gt;pNext; pHead-&gt;pNext=pA; pA=pB; if(pA==NULL) &#123; break; &#125; &#125; &#125; test1234int main()&#123; return 0;&#125; int main()","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E9%93%BE%E8%A1%A8/"}]}],"categories":[{"name":"项目技术栈","slug":"项目技术栈","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"JSON","slug":"JSON","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/JSON/"},{"name":"生产者消费者demo","slug":"生产者消费者demo","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85demo/"},{"name":"进程线程","slug":"进程线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"},{"name":"多进程/线程","slug":"多进程-线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"},{"name":"编程基础","slug":"编程基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"boa","slug":"boa","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/boa/"},{"name":"人脸识别技术栈","slug":"人脸识别技术栈","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E6%A0%88/"},{"name":"有名管道","slug":"有名管道","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93/"},{"name":"有名管道，信号量","slug":"有名管道，信号量","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%EF%BC%8C%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"线程bug","slug":"线程bug","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8Bbug/"},{"name":"信号量","slug":"信号量","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"线程通信","slug":"线程通信","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"},{"name":"链表","slug":"链表","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"线程","slug":"线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"基础","slug":"基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E5%9F%BA%E7%A1%80/"}]}