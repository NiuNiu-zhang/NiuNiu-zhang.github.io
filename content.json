{"meta":{"title":"NiuNiu","subtitle":"IT_小马哥","description":"NiuNiu的学习博客","author":"Zhang  Hao","url":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io","root":"/"},"pages":[],"posts":[{"title":"进程-linux","slug":"进程-linux","date":"2020-08-07T07:47:39.000Z","updated":"2020-08-07T07:47:39.779Z","comments":true,"path":"2020/08/07/进程-linux/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/07/%E8%BF%9B%E7%A8%8B-linux/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"网络编程传输协议详解","slug":"网络编程传输协议详解","date":"2020-08-07T07:46:19.000Z","updated":"2020-08-07T07:46:19.075Z","comments":true,"path":"2020/08/07/网络编程传输协议详解/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/07/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"诺瓦2020提前批笔试","slug":"诺瓦2020提前批笔试","date":"2020-08-07T02:21:03.000Z","updated":"2020-08-07T18:57:58.222Z","comments":true,"path":"2020/08/07/诺瓦2020提前批笔试/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/07/%E8%AF%BA%E7%93%A62020%E6%8F%90%E5%89%8D%E6%89%B9%E7%AC%94%E8%AF%95/","excerpt":"","text":"flight.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#ifndef HEAD_H#define HEAD_H/* * description: * 航班和乘客，乘客中用 GREEN、YELLOW、RED 标识身体情况， 规则: * 一列航班中 RED==0 没有问题 * RED &gt; 10% 紧急停机检查 * 0 &lt; RED &lt; 10% * 有风险，抵达目的地后进行检查 * 代码实现 **/// &lt;封装 乘客struct&gt; select 链表typedef struct passenger&#123; char * name; char * id_card; struct passenger * pNext; int flight_id; int healthcode; // 乘客的健康等级&#125;passenger_t;// &lt;封装 flight struct&gt;typedef struct flight&#123; const char * orig_city;//初始地 const char * dest_city; int flight_id; struct flight * pNext; passenger_t * pHead_passenger; //飞机包含乘客链表 int Goodlevel; //评估飞机的安全等级 int passengerNum; //保存航班的乘客总人数 int redNum; // int yellowNum;&#125;flight_t;typedef enum&#123; EN_GREEN, EN_YELLOW, EN_RED&#125;en_health_code;/* * function:create a flightHead * return:pHead_flight */flight_t * createFlight( void );/* * function:create a passengerHead * return:pHead_passenger * */passenger_t * createPassenger( void );//添加航班信息int addFlight(flight_t * pHead,int flight_id, const char * orig_city, const char * dest_city );//添加乘客信息int addPassenger( flight_t * pHead, int flight_id, char * name, char * id_card, int healthcode );int showPassenger( flight_t * pHead,int flight_id );void showFlight( flight_t * pHead);// function:计算某航班的风险值并返回int getRisk( flight_t * pHead, int flight_id );#endif flight.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include &quot;flight.h&quot;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;flight_t * createFlight( void )&#123; flight_t * pHead_flight = (flight_t * )malloc( sizeof( flight_t )); if ( NULL == pHead_flight ) &#123; return (flight_t *)0; &#125; memset( pHead_flight , &#x27;\\0&#x27; , sizeof( flight_t ) ); pHead_flight-&gt;flight_id = 0; pHead_flight-&gt;pNext = NULL; printf(&quot;create flight success\\r\\n&quot;); return pHead_flight;&#125;passenger_t * createPassenger( void )&#123; passenger_t * pHead_passenger = (passenger_t * )malloc( sizeof( passenger_t)); if ( NULL == pHead_passenger ) &#123; return ( passenger_t * )0; &#125; memset( pHead_passenger , &#x27;\\0&#x27; , sizeof( passenger_t ) ); printf(&quot;create passenger success\\r\\n&quot;); return pHead_passenger;&#125;int addFlight( flight_t * pHead, int flight_id, const char * orig_city, const char * dest_city )&#123; if ( NULL==pHead || flight_id &lt; 0 || NULL == orig_city || NULL == dest_city ) &#123; perror(&quot;param error!\\r\\n&quot;); return -1; &#125; flight_t * temp = (flight_t * )malloc( sizeof(flight_t )); memset(temp, &#x27;\\0&#x27;, sizeof(flight_t ) ); flight_t * pNew = (flight_t * )malloc( sizeof(flight_t )); memset( pNew , &#x27;\\0&#x27;, sizeof(flight_t ) ); //不能对空指针进行赋值， 要新 malloc pNew pNew-&gt;flight_id = flight_id; pNew-&gt;orig_city = orig_city; pNew-&gt;dest_city = dest_city; pNew-&gt;pHead_passenger =(passenger_t *)malloc( sizeof( passenger_t )); temp = pHead; while( temp-&gt;flight_id != flight_id &amp;&amp; temp-&gt;pNext != NULL ) //对，应该判断前一个，然后赋值好赋值 &#123; temp =temp-&gt;pNext; &#125; if (temp != NULL &amp;&amp; temp-&gt;flight_id == flight_id ) &#123; perror(&quot;flight already exist!, add error\\r\\n&quot;); return -1; &#125; temp-&gt;pNext= pNew; printf(&quot;add success\\r\\n&quot;); return 0;&#125;void showFlight( flight_t * pHead)&#123; if(NULL ==pHead) &#123; perror(&quot;param error!\\r\\n&quot;); return; &#125; flight_t* temp = pHead; while( temp != NULL ) &#123; // flight_id=0是头节点，可不打印 if( 0 == temp-&gt;flight_id ) &#123; temp = temp-&gt;pNext; &#125; printf(&quot;flight_id--%d 起始地点--%s, 目的地点--%s \\r\\n&quot;, temp-&gt;flight_id, temp-&gt;orig_city, temp-&gt;dest_city ); temp = temp-&gt;pNext; &#125; printf(&quot;show ok\\r\\n&quot;); return;&#125;int addPassenger( flight_t * pHead ,int flight_id, char * name, char * id_card, int healthcode ) &#123; if ( NULL == pHead || flight_id &lt;0 || NULL == name || NULL == id_card ) &#123; perror(&quot; param error\\r\\n&quot;); return -1; &#125; flight_t * ptmp = pHead; while ( ptmp-&gt;flight_id != flight_id ) &#123; ptmp = ptmp-&gt;pNext; if ( NULL == ptmp) &#123; perror(&quot; flight_id error!\\r\\n&quot;); return -2; &#125; &#125; passenger_t * pNew = ( passenger_t *)malloc( sizeof(passenger_t )); pNew-&gt;flight_id=flight_id; //0 green 1 yellow 2 red pNew-&gt;healthcode=healthcode; pNew-&gt;id_card = id_card; pNew-&gt;name = name; ptmp-&gt;passengerNum += 1; if( 2 == healthcode ) &#123; ptmp-&gt;redNum += 1; &#125; else if( 1 == healthcode ) &#123; ptmp-&gt;yellowNum += 1; &#125; passenger_t * pq = ( passenger_t *)malloc( sizeof(passenger_t )); pq = ptmp-&gt;pHead_passenger; while( pq-&gt;pNext != NULL) &#123; pq = pq-&gt;pNext; &#125; pq-&gt;pNext = pNew; return 0;&#125;int showPassenger( flight_t * pHead, int flight_id )&#123; if ( NULL == pHead || flight_id &lt; 0) &#123; perror(&quot; param error\\r\\n&quot;); return -1; &#125; flight_t * temp = pHead; // 用temp-&gt;pNext 做判断最后好赋值 while( temp-&gt;pNext != NULL &amp;&amp; temp-&gt;flight_id != flight_id ) &#123; temp = temp-&gt;pNext; &#125; if (temp-&gt;flight_id != flight_id &amp;&amp; temp-&gt;pNext == NULL) &#123; perror(&quot; flight_id error!\\r\\n&quot;); return -2; &#125; if (temp-&gt;flight_id == flight_id ) &#123; //passenger_t * pp = temp-&gt;pHead_passenger; 因为第一个是头节点，不打印 passenger_t * pp = temp-&gt;pHead_passenger-&gt;pNext; while ( pp != NULL) //遍历打印是 pp != NULL &#123; printf(&quot;passenger info:// name:%s, card_id:%s, healthcode:%d, flight_id:%d, origCity:%s, destCity:%s \\r\\n&quot;, pp-&gt;name,pp-&gt;id_card,pp-&gt;healthcode,pp-&gt;flight_id, temp-&gt;orig_city,temp-&gt;dest_city); pp=pp-&gt;pNext; &#125; &#125; return 0;&#125; int getRisk( flight_t * pHead, int flight_id )&#123; if ( NULL == pHead || flight_id &lt; 0 ) &#123; perror(&quot; param error!\\r\\n&quot;); return -1; &#125; flight_t * ptemp = pHead; while ( ptemp-&gt;flight_id != flight_id &amp;&amp; ptemp-&gt;pNext != NULL ) &#123; ptemp = ptemp-&gt;pNext; &#125; if ( ptemp-&gt;pNext == NULL &amp;&amp; ptemp-&gt;flight_id != flight_id) &#123; return -2; &#125; float redRisk =(float)ptemp-&gt;redNum / (float)ptemp-&gt;passengerNum; printf(&quot;passengerNum=%d, redNum=%d, yellowNum=%d\\r\\n&quot;,ptemp-&gt;passengerNum,ptemp-&gt;redNum, ptemp-&gt;yellowNum); printf(&quot;redRisk=%f\\r\\n&quot;, redRisk); if( 0 == redRisk) &#123; ptemp-&gt;Goodlevel = 0; printf(&quot;plane safe, take off\\r\\n&quot;); &#125; else if( redRisk &gt;= 0.1 ) &#123; ptemp-&gt;Goodlevel = 2; printf(&quot;dangerous!!!!stop \\r\\n&quot;); &#125; else if( redRisk &gt; 0 &amp;&amp; redRisk &lt; 0.1 ) &#123; ptemp-&gt;Goodlevel = 1; printf( &quot;just ok,but still need to be examine\\r\\n&quot; ); &#125; return 0;&#125; main.c 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &quot;flight.h&quot;int main(void)&#x27;&#123; flight_t * pHead_flight = createFlight(); passenger_t * pHead_passenger = createPassenger(); addFlight(pHead_flight, 1, &quot;zhengzhou&quot;,&quot;xian&quot;); addFlight(pHead_flight, 2, &quot;beijing&quot;,&quot;xian&quot;); //addFlight(pHead_flight, 2, &quot;xinjiang&quot;,&quot;xian&quot;); addPassenger(pHead_flight,1,&quot;Jim&quot;, &quot;12345&quot;,0); addPassenger(pHead_flight,1,&quot;SU&quot;, &quot;sadw&quot;, 2); addPassenger(pHead_flight,1,&quot;zhang&quot;,&quot;334&quot;, 1); addPassenger(pHead_flight,1,&quot;li&quot;, &quot;888&quot;, 1); addPassenger(pHead_flight,1,&quot;q&quot;, &quot;812&quot;, 1); addPassenger(pHead_flight,1,&quot;s&quot;, &quot;833&quot;, 1); addPassenger(pHead_flight,1,&quot;qwd&quot;, &quot;124&quot;, 1); addPassenger(pHead_flight,1,&quot;trgh&quot;, &quot;oa9&quot;, 1); addPassenger(pHead_flight,1,&quot;dwew&quot;, &quot;wevc&quot;,1); addPassenger(pHead_flight,1,&quot;uh&quot;, &quot;okn&quot;, 1); addPassenger(pHead_flight,2,&quot;sfd&quot;, &quot;plm&quot;, 1); addPassenger(pHead_flight,2,&quot;yth&quot;, &quot;adv&quot;, 1); addPassenger(pHead_flight,2,&quot;sf&quot;, &quot;okq&quot;, 1); addPassenger(pHead_flight,2,&quot;alib&quot;, &quot;13df&quot;,1); addPassenger(pHead_flight,2,&quot;niuniu&quot;,&quot;asf3&quot;,1); addPassenger(pHead_flight,2,&quot;gui&quot;, &quot;qa1&quot;,1); addPassenger(pHead_flight,2,&quot;ww&quot;, &quot;qa2&quot;,1); addPassenger(pHead_flight,2,&quot;gg&quot;, &quot;qa3&quot;,1); addPassenger(pHead_flight,2,&quot;ym&quot;, &quot;qa4&quot;,1); addPassenger(pHead_flight,2,&quot;shui&quot;, &quot;qa5&quot;,1); addPassenger(pHead_flight,2,&quot;alp&quot;, &quot;ws5&quot;,1); addPassenger(pHead_flight,2,&quot;hub&quot;, &quot;sf6&quot;,0); getRisk( pHead_flight, 1); getRisk( pHead_flight, 2); showFlight( pHead_flight ); showPassenger(pHead_flight, 1); return 0;&#x27;&#125; 运行效果参考：","categories":[],"tags":[{"name":"链表","slug":"链表","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"线程-linux","slug":"线程-linux","date":"2020-08-05T07:47:14.000Z","updated":"2020-08-07T09:38:33.504Z","comments":true,"path":"2020/08/05/线程-linux/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/05/%E7%BA%BF%E7%A8%8B-linux/","excerpt":"","text":"线程–轻量级进程 // 内核调度的最小单元为了进一步减少处理器的空转时间，支持多处理器，减少上下文切换开销 上下文切换：指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换，上下文切换过程中的信息被保存在进程控制块（PCB-Process Control Block）中 过程： ` [1]先挂起一个进程，把这个进程在cpu中的状态（上下文信息）存储在内存的 PCB 中 [2]在PCB中检索下一个进程的上下文并将其在CPU的寄存器中恢复 [3]跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行）并恢复该进程` linux中的线程依赖于 pthread 线程库 1、创建线程： pthread_create( pthread_t * thread, pthread_attr_t *attr,void *( *start_routine)(void *), void * arg); thread: 线程标识符 attr: 线程属性设置， NULL 表示缺省属性 start_routine: 线程执行函数，参数和返回值都是 void * arg: 传递给 线程执行函数用的参数 return: success:0 error:错误码 2、退出线程: pthread_exit( void * retval ); retval: 线程结束时的返回值， 可以通过 pthread_join() 来接收//但是使用中不能用 exit 退出线程，因为一般一个进程中包含多个线程，exit的作用是使当前进程终止，进程中所以线程都会over—所以退出线程用 pthread_exit() 来替代 线程主动结束：可以调用 pthread_exit() 一个线程终止另外一个线程： 调用 pthread_cancel() 实现// 在被取消的线程内部要 先调用 pthread_setcancel() 和 pthread_setcanceltype() 设置相应的取消状态 3、pthread_join() 以阻塞的方式等待 thread 指定的线程结束，函数返回时，被等待线程的资源被回收，如果线程已经结束，该函数会立即返回 resutn: success:0 error:错误号 函数原型： pthread_ioin( pthread_t pthread, void ** thread_result ); thread:被等待线程的标识符 thread_result: 用户定义的指针，用来接收被等待线程结束时的返回值（如果返回不为NULL） **为什么是二级指针：**原因：一级指针只能用来改变指向内存的值，传递的就是指针p内存的地址,所以修改它就是修改了它自己的指向; 4、pthread_cancel( pthread_t thread ) thread: 要取消的线程的 标识符 return: success:0 error:错误码 线程函数使用 Demo // 编译的时候需要链接 pthread thread.h #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;pthread.h&gt; #define THREAD_NUM 3 // 线程数 #define REPEAT_TIMES 5 //每个线程中的循环次数限制 #define DELAY_TIME 6.0 //循环之间的最大时间间隔 线程处理函数 void * thread_function( void * arg){ int thread_num = (int )arg; //线程总数 int delay_time = 0; //延时 int count = 0; //计调用次数 printf(&quot;thread %d start!\\r\\n&quot;,thread_num); for (count=0;count&lt;REPEAT_TIMES; count++ ) &#123; delay_time = (int)( rand() * DELAY_TIME / (RAND_MAX) ) +1 ; sleep( delay_time ); //随机等待1--6 s, 模拟任务完成的时间随机 printf(&quot;Thread %d :job %d delay = %d\\r\\n&quot;, thread_num,count, delay_time); &#125; printf(&quot;Thread %d is finished\\r\\n&quot;, thread_num); pthread_exit(NULL); //任务完成自行结束 } main.c #include “thread.h” int main( void ){ pthread_t thread[THREAD_NUM]; //定义存放 thread 号的类型数组 int no = 0,res; void * thread_ret; srand( time( NULL )); //埋下时间种子 for( no=0; no&lt;THREAD_NUM; no++) &#123; res = pthread_create(&amp;thread[no], NULL, thread_function, (void*)no ); //创建的时候是 pthread_t * // no 标识是第几个线程 if ( res != 0 ) //create error &#123; printf(&quot;Create thread %d error\\r\\n&quot;, no); exit(res); // 结束进程， &lt;stdlib.h&gt; 参数不为0都异常 &#125; &#125; printf(&quot;Create threads success!\\r\\n&quot;); for( no=0;no&lt;THREAD_NUM;no++) &#123; // pthread_join: pthread_t thread res = pthread_join( thread[no], &amp;thread_ret); //阻塞式等待线程退出 //param_2 被等待线程结束的返回值, void ** thread_result if ( 0 == res ) //success:0 error:错误号 &#123; printf(&quot;Thread %d joined\\r\\n&quot;,no); &#125; else &#123; printf(&quot;Thread %d joined failed\\r\\n&quot;, no); &#125; &#125; return 0; } 运行情况：","categories":[{"name":"多进程/线程","slug":"多进程-线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"进制间转换","slug":"进制间转换","date":"2020-08-04T11:08:07.000Z","updated":"2020-08-04T16:58:12.302Z","comments":true,"path":"2020/08/04/进制间转换/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/04/%E8%BF%9B%E5%88%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"&lt;10进制—&gt;2进制&gt; 1234567ex: 19---&gt; 19 / 2 = 9....1 9 / 2 = 4....1 4 / 2 = 2....0 2 / 2 = 1....0 1 / 2 = 0....1 反序取余数 10011 10进制中的 小数部分–&gt;2进制 1234ex: 0.75小数不断×2取整，直到没有小数为止，注意:不是所有的小数都可以转为 2 进制 0.75 * 2 = 1.5 取整 1 0.5 * 2 = 1 顺序取数得: 0.11 &lt;16进制—-&gt; 10进制 &gt; 123456716进制 是 16 进 1 0 1 2 3 4 5 6 7 8 9 A(10) B C D E F(15)ex: 2AF5 = 5* 16^0 + F*16^1 + A*16^2 + 2*16^3 = 5 + 15*16 + 10*256 + 2*4096 = 5 + 240 + 2560 + 8192 = 10997 &lt;10进制 —-&gt; 16进制&gt; 1234567余数定理分解ex： 48774877 / 16 = 304....13 304 / 16 = 19....0 19 / 16 = 1.....3 1 / 16 = 0.....1 结果 = 130D (注意顺序)","categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"stm32-port1","slug":"stm32-port1","date":"2020-08-04T04:37:50.000Z","updated":"2020-08-04T04:37:50.998Z","comments":true,"path":"2020/08/04/stm32-port1/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/04/stm32-port1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-08-02T19:39:29.453Z","updated":"2020-08-07T06:54:22.548Z","comments":true,"path":"2020/08/03/hello-world/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/03/hello-world/","excerpt":"","text":"欢迎来到 NiuNiu 的技术经验分享博客网站但凡流行的工具、技术，都是入门易，精通难，想有所成就，都需要不懈的努力和漫长的积累，愿诸君与我共勉！回首向来萧瑟处，归去，也无风雨也无晴~","categories":[],"tags":[]},{"title":"单向不循环链表","slug":"单向不循环链表","date":"2020-08-01T16:48:16.000Z","updated":"2020-08-07T09:58:15.778Z","comments":true,"path":"2020/08/02/单向不循环链表/","link":"","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/2020/08/02/%E5%8D%95%E5%90%91%E4%B8%8D%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/","excerpt":"","text":"链表： 动态的数据结构，分为数据域和指针域， 动态进行存储分配，实现数据增删 优点： ​ 1、存储空间动态分配，可以根据实际需要使用 ​ 2、不需要地址连续的存储空间 ​ 3、插入/删除操作只需通过修改指针实现，不必移动数据元素， 操作时间效率高 ，插入删除事件复杂度 O(1) 缺点： ​ 1、每个链节点需要设置指针域（ 存储密度小 ） ​ 2、是一种非随机存储结构，查找/定位等操作都需要顺序扫描链表实现，时间效率低 O(n) [TOC] Demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258/* 头节点:数据域为空 头节点:数据域为空 malloc 申请 &lt;malloc.h&gt; memset 初始化 &lt;string.h&gt;*/typedef int datatype; typedef struct link&#123; datatype data; struct link * pNext;&#125;Link;// 枚举 中间用, 未赋值默认第一个为0enum opt&#123; ERR=-1, OK, TAIL=-1, HEAD,&#125;;// [1]创建链表---即生成头节点Link * createLink(void);Link * createLink(void)&#123; Link * pHead =NULL; pHead=(Link *)malloc(sizeof(Link)); if(NULL==pHead) &#123; return NULL; &#125; memset(pHead,&#x27;\\0&#x27;,sizeof(Link)); return pHead;&#125;// [2]插入节点---头插，尾插，中间插//根据位置给链表添加节点//参数：链表首地址，要添加的元素，和插入的位置//HEAD=0 TAIL=-1 其他中间//返回值 成功 OK 失败 ERRint InsertLink(Link * pHead, datatype item,int offset);int InsertLink(Link * pHead, datatype item,int offset)&#123; if(NULL==pHead) &#123; return ERR; &#125; int k=0; Link * pNew=NULL; Link * pTmp=pHead; //如果写pHead-&gt;pNext要判断是否为空所以为了方便写pHead pNew=(Link *)malloc(sizeof(Link)); if(NULL==pNew) &#123; return ERR; &#125; pNew-&gt;data=item; pNew-&gt;pNext=NULL; switch(offset) &#123;case HEAD: pNew-&gt;pNext=pHead-&gt;pNext; pHead-&gt;pNext=pNew; break;case TAIL: while(pTmp-&gt;pNext!=NULL) &#123; pTmp=pTmp-&gt;pNext; &#125; pTmp-&gt;pNext=pNew; break;default: while(k &lt; offset-1 &amp;&amp; pTmp != NULL) //pTmp!=NULL说明找到插入位置，如果pTmp==NULL,表示未找到要free(pNew)再返回报错 &#123; k++; pTmp=pTmp-&gt;pNext; &#125; if(pTmp==NULL) //先判断是否为空 &#123; free(pNew); return ERR; &#125; pNew-&gt;pNext=pTmp-&gt;pNext; pTmp-&gt;pNext=pNew; break; &#125;&#125;// [3]打印输出---遍历int show(Link * pHead);int show(Link * pHead)&#123; if(NULL==pHead) &#123; return ERR; &#125; Link * pTmp=pHead-&gt;pNext; while(pTmp!=NULL) &#123; printf(&quot; %d &quot;,pTmp-&gt;data); pTmp=pTmp-&gt;pNext; &#125; printf(&quot;\\n&quot;);&#125;// [4]删除节点----头删，尾删，中间删int DeleteLink(Link * pHead,int offset,datatype * pData);int DeleteLink(Link * pHead,int offset,datatype * pData)&#123; if(NULL==pHead||NULL==pData) &#123; return ERR; &#125; Link * pDel=NULL; Link * pPre=NULL; int k=0; switch(offset) &#123; case HEAD: pDel=pHead-&gt;pNext; if(pDel==NULL) //一定要判断 &#123; *pData=0; printf(&quot;链表为空！\\n&quot;); return ERR; &#125; pHead-&gt;pNext=pDel-&gt;pNext; //先将删除的数保存 *pData=pDel-&gt;data; free(pDel); pDel=NULL; break; case TAIL: pPre=pHead; pDel=pHead-&gt;pNext; if(pDel==NULL) //说明没有什么删除的，空链表是pHead-&gt;pNext为空 &#123; printf(&quot;链表为空!\\n&quot;); *pData=0; return ERR; while(pDel-&gt;pNext!=NULL) &#123; pPre=pDel; pDel=pDel-&gt;pNext; &#125; //保存删除的数据v *pData=pDel-&gt;data; free(pDel); pDel=NULL; //把pre变成尾节点 pPre-&gt;pNext=NULL; break; &#125; default: pPre=pHead; pDel=pHead-&gt;pNext; k=0; while(k&lt;offset-1&amp;&amp;pDel!=NULL) &#123; k++; pPre=pDel; //是pPre=pDel;; pDel=pDel-&gt;pNext; &#125; if(pDel==NULL) &#123; printf(&quot;链表为空!\\n&quot;); *pData=0; return ERR; &#125; *pData=pDel-&gt;data; pPre-&gt;pNext=pDel-&gt;pNext; free(pDel); pDel=NULL; break; &#125;&#125;// [5]销毁链表Link * Destroy(Link * pHead);Link * Destroy(Link * pHead)&#123; if(NULL==pHead) &#123; return NULL; &#125; Link * pDel=NULL; //while(pDel!=NULL) //while(1)是死循环 永远成立； while(1) &#123;//找到链表中的首节点 pDel=pHead-&gt;pNext; if(pDel==NULL) &#123; break; &#125; //保护好首节点后的所有节点 pHead-&gt;pNext=pDel-&gt;pNext; //释放首节点 free(pDel); pDel=NULL; &#125; //最后再释放头节点 free(pHead); pHead=NULL; printf(&quot;链表已删除\\n&quot;); return pHead; //一定要返回 pHead 否则会错误&#125;// [6]链表逆序---拓展int Negative(Link * pHead); //Negative sequence 逆序int Negative(Link * pHead) //Negative sequence 逆序&#123; if(NULL==pHead) &#123; return ERR; &#125; Link * pA=NULL; Link * pB=NULL; pA=pHead-&gt;pNext; //保护好头节点后的所有节点 //原链表变为空链表 pHead-&gt;pNext=NULL; //保护好首节点后的所有节点 while(1) &#123; pB=pA-&gt;pNext; //首节点插入到新链表 pA-&gt;pNext=pHead-&gt;pNext; pHead-&gt;pNext=pA; pA=pB; if(pA==NULL) &#123; break; &#125; &#125; &#125; test1234int main()&#123; return 0;&#125; int main()","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E9%93%BE%E8%A1%A8/"}]}],"categories":[{"name":"多进程/线程","slug":"多进程-线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"},{"name":"编程基础","slug":"编程基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"线程","slug":"线程","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"基础","slug":"基础","permalink":"https://github.com/NiuNiu-zhang/NiuNiu-zhang.github.io/tags/%E5%9F%BA%E7%A1%80/"}]}